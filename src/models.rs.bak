#![allow(unused_qualifications)]

use crate::models;
#[cfg(any(feature = "client", feature = "server"))]
use crate::header;

/// The access record which links users to roles.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AccessRecord {
    /// Unique identifier for the record, can be specified on record creation.
    #[serde(rename = "recordId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub record_id: Option<String>,

    /// A helpful name for this record
    #[serde(rename = "name")]
    pub name: String,

    /// More details about this record
    #[serde(rename = "description")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<swagger::Nullable<String>>,

    /// Percentage capacity of record that is filled.
    #[serde(rename = "capacity")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub capacity: Option<f32>,

    /// The expected last time the record was updated
    #[serde(rename = "lastUpdated")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_updated: Option<chrono::DateTime::<chrono::Utc>>,

    /// Current status of the access record.
    // Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,

    #[serde(rename = "account")]
    pub account: models::AccessRecordAccount,

    /// The list of users this record applies to
    #[serde(rename = "users")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub users: Option<swagger::Nullable<Vec<models::User>>>,

    /// The list of admin that can edit this record even if they do not have global record edit permissions.
    #[serde(rename = "admins")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub admins: Option<swagger::Nullable<Vec<models::User>>>,

    /// The list of groups this record applies to. Users in these groups will be receive access to the resources listed.
    #[serde(rename = "groups")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub groups: Option<swagger::Nullable<Vec<models::LinkedGroup>>>,

    /// A list of statements which match roles to resources.
    #[serde(rename = "statements")]
    pub statements: Vec<models::Statement>,

    #[serde(rename = "links")]
    pub links: models::AccountLinks,

    /// The tags associated with this resource, this property is an map. { key1: value1, key2: value2 }
    #[serde(rename = "tags")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags: Option<swagger::Nullable<std::collections::HashMap<String, String>>>,

}

impl AccessRecord {
    #[allow(clippy::new_without_default)]
    pub fn new(name: String, account: models::AccessRecordAccount, statements: Vec<models::Statement>, links: models::AccountLinks, ) -> AccessRecord {
        AccessRecord {
            record_id: None,
            name,
            description: None,
            capacity: None,
            last_updated: None,
            status: None,
            account,
            users: None,
            admins: None,
            groups: None,
            statements,
            links,
            tags: None,
        }
    }
}

/// Converts the AccessRecord value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AccessRecord {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.record_id.as_ref().map(|record_id| {
                vec![
                    "recordId".to_string(),
                    record_id.to_string(),
                ].join(",")
            }),


            Some("name".to_string()),
            Some(self.name.to_string()),


            self.description.as_ref().map(|description| {
                vec![
                    "description".to_string(),
                    description.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.capacity.as_ref().map(|capacity| {
                vec![
                    "capacity".to_string(),
                    capacity.to_string(),
                ].join(",")
            }),

            // Skipping lastUpdated in query parameter serialization


            self.status.as_ref().map(|status| {
                vec![
                    "status".to_string(),
                    status.to_string(),
                ].join(",")
            }),

            // Skipping account in query parameter serialization

            // Skipping users in query parameter serialization

            // Skipping admins in query parameter serialization

            // Skipping groups in query parameter serialization

            // Skipping statements in query parameter serialization

            // Skipping links in query parameter serialization

            // Skipping tags in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AccessRecord value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AccessRecord {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub record_id: Vec<String>,
            pub name: Vec<String>,
            pub description: Vec<String>,
            pub capacity: Vec<f32>,
            pub last_updated: Vec<chrono::DateTime::<chrono::Utc>>,
            pub status: Vec<String>,
            pub account: Vec<models::AccessRecordAccount>,
            pub users: Vec<Vec<models::User>>,
            pub admins: Vec<Vec<models::User>>,
            pub groups: Vec<Vec<models::LinkedGroup>>,
            pub statements: Vec<Vec<models::Statement>>,
            pub links: Vec<models::AccountLinks>,
            pub tags: Vec<std::collections::HashMap<String, String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AccessRecord".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "recordId" => intermediate_rep.record_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "description" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AccessRecord".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "capacity" => intermediate_rep.capacity.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lastUpdated" => intermediate_rep.last_updated.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "account" => intermediate_rep.account.push(<models::AccessRecordAccount as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "users" => return std::result::Result::Err("Parsing a container in this style is not supported in AccessRecord".to_string()),
                    "admins" => return std::result::Result::Err("Parsing a container in this style is not supported in AccessRecord".to_string()),
                    "groups" => return std::result::Result::Err("Parsing a container in this style is not supported in AccessRecord".to_string()),
                    "statements" => return std::result::Result::Err("Parsing a container in this style is not supported in AccessRecord".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "links" => intermediate_rep.links.push(<models::AccountLinks as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "tags" => return std::result::Result::Err("Parsing a container in this style is not supported in AccessRecord".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AccessRecord".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AccessRecord {
            record_id: intermediate_rep.record_id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in AccessRecord".to_string())?,
            description: std::result::Result::Err("Nullable types not supported in AccessRecord".to_string())?,
            capacity: intermediate_rep.capacity.into_iter().next(),
            last_updated: intermediate_rep.last_updated.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            account: intermediate_rep.account.into_iter().next().ok_or_else(|| "account missing in AccessRecord".to_string())?,
            users: std::result::Result::Err("Nullable types not supported in AccessRecord".to_string())?,
            admins: std::result::Result::Err("Nullable types not supported in AccessRecord".to_string())?,
            groups: std::result::Result::Err("Nullable types not supported in AccessRecord".to_string())?,
            statements: intermediate_rep.statements.into_iter().next().ok_or_else(|| "statements missing in AccessRecord".to_string())?,
            links: intermediate_rep.links.into_iter().next().ok_or_else(|| "links missing in AccessRecord".to_string())?,
            tags: std::result::Result::Err("Nullable types not supported in AccessRecord".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AccessRecord> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AccessRecord>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AccessRecord>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AccessRecord - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AccessRecord> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AccessRecord as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AccessRecord - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AccessRecordAccount {
    #[serde(rename = "accountId")]
    pub account_id: String,

}

impl AccessRecordAccount {
    #[allow(clippy::new_without_default)]
    pub fn new(account_id: String, ) -> AccessRecordAccount {
        AccessRecordAccount {
            account_id,
        }
    }
}

/// Converts the AccessRecordAccount value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AccessRecordAccount {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("accountId".to_string()),
            Some(self.account_id.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AccessRecordAccount value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AccessRecordAccount {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub account_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AccessRecordAccount".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "accountId" => intermediate_rep.account_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AccessRecordAccount".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AccessRecordAccount {
            account_id: intermediate_rep.account_id.into_iter().next().ok_or_else(|| "accountId missing in AccessRecordAccount".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AccessRecordAccount> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AccessRecordAccount>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AccessRecordAccount>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AccessRecordAccount - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AccessRecordAccount> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AccessRecordAccount as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AccessRecordAccount - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// A collection of access records
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AccessRecordCollection {
    /// A list of access records
    #[serde(rename = "records")]
    pub records: Vec<models::AccessRecord>,

    #[serde(rename = "pagination")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pagination: Option<models::Pagination>,

    #[serde(rename = "links")]
    pub links: models::CollectionLinks,

}

impl AccessRecordCollection {
    #[allow(clippy::new_without_default)]
    pub fn new(records: Vec<models::AccessRecord>, links: models::CollectionLinks, ) -> AccessRecordCollection {
        AccessRecordCollection {
            records,
            pagination: None,
            links,
        }
    }
}

/// Converts the AccessRecordCollection value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AccessRecordCollection {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping records in query parameter serialization

            // Skipping pagination in query parameter serialization

            // Skipping links in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AccessRecordCollection value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AccessRecordCollection {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub records: Vec<Vec<models::AccessRecord>>,
            pub pagination: Vec<models::Pagination>,
            pub links: Vec<models::CollectionLinks>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AccessRecordCollection".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "records" => return std::result::Result::Err("Parsing a container in this style is not supported in AccessRecordCollection".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "pagination" => intermediate_rep.pagination.push(<models::Pagination as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "links" => intermediate_rep.links.push(<models::CollectionLinks as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AccessRecordCollection".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AccessRecordCollection {
            records: intermediate_rep.records.into_iter().next().ok_or_else(|| "records missing in AccessRecordCollection".to_string())?,
            pagination: intermediate_rep.pagination.into_iter().next(),
            links: intermediate_rep.links.into_iter().next().ok_or_else(|| "links missing in AccessRecordCollection".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AccessRecordCollection> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AccessRecordCollection>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AccessRecordCollection>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AccessRecordCollection - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AccessRecordCollection> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AccessRecordCollection as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AccessRecordCollection - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// The access requested by a user.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AccessRequest {
    /// Unique identifier for the request.
    #[serde(rename = "requestId")]
    pub request_id: String,

    /// The expected last time the request was updated
    #[serde(rename = "lastUpdated")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_updated: Option<chrono::DateTime::<chrono::Utc>>,

    /// Current status of the access request.
    // Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,

    #[serde(rename = "access")]
    pub access: models::AccessTemplate,

    #[serde(rename = "links")]
    pub links: models::AccountLinks,

    /// The tags associated with this resource, this property is an map. { key1: value1, key2: value2 }
    #[serde(rename = "tags")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags: Option<swagger::Nullable<std::collections::HashMap<String, String>>>,

}

impl AccessRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(request_id: String, access: models::AccessTemplate, links: models::AccountLinks, ) -> AccessRequest {
        AccessRequest {
            request_id,
            last_updated: None,
            status: None,
            access,
            links,
            tags: None,
        }
    }
}

/// Converts the AccessRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AccessRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("requestId".to_string()),
            Some(self.request_id.to_string()),

            // Skipping lastUpdated in query parameter serialization


            self.status.as_ref().map(|status| {
                vec![
                    "status".to_string(),
                    status.to_string(),
                ].join(",")
            }),

            // Skipping access in query parameter serialization

            // Skipping links in query parameter serialization

            // Skipping tags in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AccessRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AccessRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub request_id: Vec<String>,
            pub last_updated: Vec<chrono::DateTime::<chrono::Utc>>,
            pub status: Vec<String>,
            pub access: Vec<models::AccessTemplate>,
            pub links: Vec<models::AccountLinks>,
            pub tags: Vec<std::collections::HashMap<String, String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AccessRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "requestId" => intermediate_rep.request_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lastUpdated" => intermediate_rep.last_updated.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "access" => intermediate_rep.access.push(<models::AccessTemplate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "links" => intermediate_rep.links.push(<models::AccountLinks as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "tags" => return std::result::Result::Err("Parsing a container in this style is not supported in AccessRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AccessRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AccessRequest {
            request_id: intermediate_rep.request_id.into_iter().next().ok_or_else(|| "requestId missing in AccessRequest".to_string())?,
            last_updated: intermediate_rep.last_updated.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            access: intermediate_rep.access.into_iter().next().ok_or_else(|| "access missing in AccessRequest".to_string())?,
            links: intermediate_rep.links.into_iter().next().ok_or_else(|| "links missing in AccessRequest".to_string())?,
            tags: std::result::Result::Err("Nullable types not supported in AccessRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AccessRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AccessRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AccessRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AccessRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AccessRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AccessRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AccessRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// A collection of access requests
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AccessRequestCollection {
    /// A list of access requests
    #[serde(rename = "records")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub records: Option<Vec<models::AccessRequest>>,

    #[serde(rename = "pagination")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pagination: Option<models::Pagination>,

    #[serde(rename = "links")]
    pub links: models::CollectionLinks,

}

impl AccessRequestCollection {
    #[allow(clippy::new_without_default)]
    pub fn new(links: models::CollectionLinks, ) -> AccessRequestCollection {
        AccessRequestCollection {
            records: None,
            pagination: None,
            links,
        }
    }
}

/// Converts the AccessRequestCollection value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AccessRequestCollection {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping records in query parameter serialization

            // Skipping pagination in query parameter serialization

            // Skipping links in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AccessRequestCollection value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AccessRequestCollection {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub records: Vec<Vec<models::AccessRequest>>,
            pub pagination: Vec<models::Pagination>,
            pub links: Vec<models::CollectionLinks>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AccessRequestCollection".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "records" => return std::result::Result::Err("Parsing a container in this style is not supported in AccessRequestCollection".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "pagination" => intermediate_rep.pagination.push(<models::Pagination as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "links" => intermediate_rep.links.push(<models::CollectionLinks as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AccessRequestCollection".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AccessRequestCollection {
            records: intermediate_rep.records.into_iter().next(),
            pagination: intermediate_rep.pagination.into_iter().next(),
            links: intermediate_rep.links.into_iter().next().ok_or_else(|| "links missing in AccessRequestCollection".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AccessRequestCollection> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AccessRequestCollection>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AccessRequestCollection>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AccessRequestCollection - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AccessRequestCollection> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AccessRequestCollection as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AccessRequestCollection - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// A dynamic body to support request PATCH operations
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AccessRequestResponse {
    /// New result, either approve or deny the request
    // Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

}

impl AccessRequestResponse {
    #[allow(clippy::new_without_default)]
    pub fn new(status: String, ) -> AccessRequestResponse {
        AccessRequestResponse {
            status,
        }
    }
}

/// Converts the AccessRequestResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AccessRequestResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("status".to_string()),
            Some(self.status.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AccessRequestResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AccessRequestResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AccessRequestResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AccessRequestResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AccessRequestResponse {
            status: intermediate_rep.status.into_iter().next().ok_or_else(|| "status missing in AccessRequestResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AccessRequestResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AccessRequestResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AccessRequestResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AccessRequestResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AccessRequestResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AccessRequestResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AccessRequestResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// A logical grouping of access related elements
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AccessTemplate {
    /// The list of users the access applies to
    #[serde(rename = "users")]
    pub users: Vec<models::User>,

    /// A list of statements which match roles to resources.
    #[serde(rename = "statements")]
    pub statements: Vec<models::Statement>,

}

impl AccessTemplate {
    #[allow(clippy::new_without_default)]
    pub fn new(users: Vec<models::User>, statements: Vec<models::Statement>, ) -> AccessTemplate {
        AccessTemplate {
            users,
            statements,
        }
    }
}

/// Converts the AccessTemplate value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AccessTemplate {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping users in query parameter serialization

            // Skipping statements in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AccessTemplate value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AccessTemplate {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub users: Vec<Vec<models::User>>,
            pub statements: Vec<Vec<models::Statement>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AccessTemplate".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "users" => return std::result::Result::Err("Parsing a container in this style is not supported in AccessTemplate".to_string()),
                    "statements" => return std::result::Result::Err("Parsing a container in this style is not supported in AccessTemplate".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AccessTemplate".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AccessTemplate {
            users: intermediate_rep.users.into_iter().next().ok_or_else(|| "users missing in AccessTemplate".to_string())?,
            statements: intermediate_rep.statements.into_iter().next().ok_or_else(|| "statements missing in AccessTemplate".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AccessTemplate> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AccessTemplate>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AccessTemplate>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AccessTemplate - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AccessTemplate> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AccessTemplate as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AccessTemplate - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Account {
    #[serde(rename = "accountId")]
    pub account_id: String,

    #[serde(rename = "createdTime")]
    pub created_time: chrono::DateTime::<chrono::Utc>,

    #[serde(rename = "name")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<swagger::Nullable<String>>,

    #[serde(rename = "company")]
    pub company: serde_json::Value,

    #[serde(rename = "links")]
    pub links: models::AccountLinks,

}

impl Account {
    #[allow(clippy::new_without_default)]
    pub fn new(account_id: String, created_time: chrono::DateTime::<chrono::Utc>, company: serde_json::Value, links: models::AccountLinks, ) -> Account {
        Account {
            account_id,
            created_time,
            name: None,
            company,
            links,
        }
    }
}

/// Converts the Account value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Account {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("accountId".to_string()),
            Some(self.account_id.to_string()),

            // Skipping createdTime in query parameter serialization


            self.name.as_ref().map(|name| {
                vec![
                    "name".to_string(),
                    name.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping company in query parameter serialization

            // Skipping links in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Account value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Account {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub account_id: Vec<String>,
            pub created_time: Vec<chrono::DateTime::<chrono::Utc>>,
            pub name: Vec<String>,
            pub company: Vec<serde_json::Value>,
            pub links: Vec<models::AccountLinks>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Account".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "accountId" => intermediate_rep.account_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "createdTime" => intermediate_rep.created_time.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "name" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Account".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "company" => intermediate_rep.company.push(<serde_json::Value as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "links" => intermediate_rep.links.push(<models::AccountLinks as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Account".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Account {
            account_id: intermediate_rep.account_id.into_iter().next().ok_or_else(|| "accountId missing in Account".to_string())?,
            created_time: intermediate_rep.created_time.into_iter().next().ok_or_else(|| "createdTime missing in Account".to_string())?,
            name: std::result::Result::Err("Nullable types not supported in Account".to_string())?,
            company: intermediate_rep.company.into_iter().next().ok_or_else(|| "company missing in Account".to_string())?,
            links: intermediate_rep.links.into_iter().next().ok_or_else(|| "links missing in Account".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Account> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Account>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Account>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Account - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Account> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Account as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Account - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AccountCollection {
    #[serde(rename = "accounts")]
    pub accounts: models::Account,

}

impl AccountCollection {
    #[allow(clippy::new_without_default)]
    pub fn new(accounts: models::Account, ) -> AccountCollection {
        AccountCollection {
            accounts,
        }
    }
}

/// Converts the AccountCollection value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AccountCollection {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping accounts in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AccountCollection value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AccountCollection {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub accounts: Vec<models::Account>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AccountCollection".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "accounts" => intermediate_rep.accounts.push(<models::Account as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AccountCollection".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AccountCollection {
            accounts: intermediate_rep.accounts.into_iter().next().ok_or_else(|| "accounts missing in AccountCollection".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AccountCollection> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AccountCollection>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AccountCollection>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AccountCollection - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AccountCollection> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AccountCollection as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AccountCollection - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AccountLinks {
    #[serde(rename = "self")]
    pub param_self: swagger::Nullable<models::Link>,

}

impl AccountLinks {
    #[allow(clippy::new_without_default)]
    pub fn new(param_self: swagger::Nullable<models::Link>, ) -> AccountLinks {
        AccountLinks {
            param_self,
        }
    }
}

/// Converts the AccountLinks value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AccountLinks {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping self in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AccountLinks value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AccountLinks {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub param_self: Vec<models::Link>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AccountLinks".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "self" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AccountLinks".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AccountLinks".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AccountLinks {
            param_self: std::result::Result::Err("Nullable types not supported in AccountLinks".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AccountLinks> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AccountLinks>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AccountLinks>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AccountLinks - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AccountLinks> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AccountLinks as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AccountLinks - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// The delegation response.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ApplicationDelegation {
    /// Redirect the user to this url to automatically log them into a third-party application.
    #[serde(rename = "authenticationUrl")]
    pub authentication_url: String,

}

impl ApplicationDelegation {
    #[allow(clippy::new_without_default)]
    pub fn new(authentication_url: String, ) -> ApplicationDelegation {
        ApplicationDelegation {
            authentication_url,
        }
    }
}

/// Converts the ApplicationDelegation value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ApplicationDelegation {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("authenticationUrl".to_string()),
            Some(self.authentication_url.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ApplicationDelegation value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ApplicationDelegation {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub authentication_url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ApplicationDelegation".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "authenticationUrl" => intermediate_rep.authentication_url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ApplicationDelegation".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ApplicationDelegation {
            authentication_url: intermediate_rep.authentication_url.into_iter().next().ok_or_else(|| "authenticationUrl missing in ApplicationDelegation".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ApplicationDelegation> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ApplicationDelegation>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ApplicationDelegation>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ApplicationDelegation - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ApplicationDelegation> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ApplicationDelegation as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ApplicationDelegation - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ClaimRequest {
    /// The parent resource to add a sub-resource to. The resource must have a resource configuration that add the permission CLAIM for this to work.
    #[serde(rename = "collectionResource")]
    pub collection_resource: String,

    /// The sub-resource the user is requesting Admin ownership over.
    #[serde(rename = "resourceId")]
    pub resource_id: String,

}

impl ClaimRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(collection_resource: String, resource_id: String, ) -> ClaimRequest {
        ClaimRequest {
            collection_resource,
            resource_id,
        }
    }
}

/// Converts the ClaimRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ClaimRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("collectionResource".to_string()),
            Some(self.collection_resource.to_string()),


            Some("resourceId".to_string()),
            Some(self.resource_id.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ClaimRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ClaimRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub collection_resource: Vec<String>,
            pub resource_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ClaimRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "collectionResource" => intermediate_rep.collection_resource.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "resourceId" => intermediate_rep.resource_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ClaimRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ClaimRequest {
            collection_resource: intermediate_rep.collection_resource.into_iter().next().ok_or_else(|| "collectionResource missing in ClaimRequest".to_string())?,
            resource_id: intermediate_rep.resource_id.into_iter().next().ok_or_else(|| "resourceId missing in ClaimRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ClaimRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ClaimRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ClaimRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ClaimRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ClaimRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ClaimRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ClaimRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// A client configuration.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Client {
    /// The unique ID of the client.
    #[serde(rename = "clientId")]
    pub client_id: String,

    #[serde(rename = "createdTime")]
    pub created_time: chrono::DateTime::<chrono::Utc>,

    /// The name of the client
    #[serde(rename = "name")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<swagger::Nullable<String>>,

    #[serde(rename = "options")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub options: Option<models::ClientOptions>,

    /// A list of the service client access keys.
    #[serde(rename = "verificationKeys")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub verification_keys: Option<Vec<models::ClientAccessKey>>,

    /// The tags associated with this resource, this property is an map. { key1: value1, key2: value2 }
    #[serde(rename = "tags")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags: Option<swagger::Nullable<std::collections::HashMap<String, String>>>,

}

impl Client {
    #[allow(clippy::new_without_default)]
    pub fn new(client_id: String, created_time: chrono::DateTime::<chrono::Utc>, ) -> Client {
        Client {
            client_id,
            created_time,
            name: None,
            options: None,
            verification_keys: None,
            tags: None,
        }
    }
}

/// Converts the Client value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Client {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("clientId".to_string()),
            Some(self.client_id.to_string()),

            // Skipping createdTime in query parameter serialization


            self.name.as_ref().map(|name| {
                vec![
                    "name".to_string(),
                    name.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping options in query parameter serialization

            // Skipping verificationKeys in query parameter serialization

            // Skipping tags in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Client value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Client {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub client_id: Vec<String>,
            pub created_time: Vec<chrono::DateTime::<chrono::Utc>>,
            pub name: Vec<String>,
            pub options: Vec<models::ClientOptions>,
            pub verification_keys: Vec<Vec<models::ClientAccessKey>>,
            pub tags: Vec<std::collections::HashMap<String, String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Client".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "clientId" => intermediate_rep.client_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "createdTime" => intermediate_rep.created_time.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "name" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Client".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "options" => intermediate_rep.options.push(<models::ClientOptions as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "verificationKeys" => return std::result::Result::Err("Parsing a container in this style is not supported in Client".to_string()),
                    "tags" => return std::result::Result::Err("Parsing a container in this style is not supported in Client".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing Client".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Client {
            client_id: intermediate_rep.client_id.into_iter().next().ok_or_else(|| "clientId missing in Client".to_string())?,
            created_time: intermediate_rep.created_time.into_iter().next().ok_or_else(|| "createdTime missing in Client".to_string())?,
            name: std::result::Result::Err("Nullable types not supported in Client".to_string())?,
            options: intermediate_rep.options.into_iter().next(),
            verification_keys: intermediate_rep.verification_keys.into_iter().next(),
            tags: std::result::Result::Err("Nullable types not supported in Client".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Client> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Client>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Client>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Client - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Client> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Client as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Client - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// A client access key configuration. The configuration contains information about the key. On first creation the configuration also contains the raw `clientSecret` and `accessKey` for use with OAuth and the Authress SDKs.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ClientAccessKey {
    /// The unique ID of the client.
    #[serde(rename = "keyId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub key_id: Option<String>,

    /// The unique ID of the client.
    #[serde(rename = "clientId")]
    pub client_id: String,

    #[serde(rename = "generationDate")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub generation_date: Option<chrono::DateTime::<chrono::Utc>>,

    /// The unencoded OAuth client secret used with the OAuth endpoints to request a JWT using the `client_credentials` grant type. Pass the clientId and the clientSecret to the documented /tokens endpoint.
    #[serde(rename = "clientSecret")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub client_secret: Option<String>,

    /// An encoded access key which contains identifying information for client access token creation. For direct use with the Authress SDKs. This private access key must be saved on first creation as it is discarded afterwards. Authress only saves the corresponding public key to verify the private access key.
    #[serde(rename = "accessKey")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub access_key: Option<String>,

}

impl ClientAccessKey {
    #[allow(clippy::new_without_default)]
    pub fn new(client_id: String, ) -> ClientAccessKey {
        ClientAccessKey {
            key_id: None,
            client_id,
            generation_date: None,
            client_secret: None,
            access_key: None,
        }
    }
}

/// Converts the ClientAccessKey value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ClientAccessKey {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.key_id.as_ref().map(|key_id| {
                vec![
                    "keyId".to_string(),
                    key_id.to_string(),
                ].join(",")
            }),


            Some("clientId".to_string()),
            Some(self.client_id.to_string()),

            // Skipping generationDate in query parameter serialization


            self.client_secret.as_ref().map(|client_secret| {
                vec![
                    "clientSecret".to_string(),
                    client_secret.to_string(),
                ].join(",")
            }),


            self.access_key.as_ref().map(|access_key| {
                vec![
                    "accessKey".to_string(),
                    access_key.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ClientAccessKey value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ClientAccessKey {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub key_id: Vec<String>,
            pub client_id: Vec<String>,
            pub generation_date: Vec<chrono::DateTime::<chrono::Utc>>,
            pub client_secret: Vec<String>,
            pub access_key: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ClientAccessKey".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "keyId" => intermediate_rep.key_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "clientId" => intermediate_rep.client_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "generationDate" => intermediate_rep.generation_date.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "clientSecret" => intermediate_rep.client_secret.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "accessKey" => intermediate_rep.access_key.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ClientAccessKey".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ClientAccessKey {
            key_id: intermediate_rep.key_id.into_iter().next(),
            client_id: intermediate_rep.client_id.into_iter().next().ok_or_else(|| "clientId missing in ClientAccessKey".to_string())?,
            generation_date: intermediate_rep.generation_date.into_iter().next(),
            client_secret: intermediate_rep.client_secret.into_iter().next(),
            access_key: intermediate_rep.access_key.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ClientAccessKey> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ClientAccessKey>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ClientAccessKey>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ClientAccessKey - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ClientAccessKey> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ClientAccessKey as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ClientAccessKey - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// The collection of a list of clients
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ClientCollection {
    /// A list of clients
    #[serde(rename = "clients")]
    pub clients: Vec<models::Client>,

    #[serde(rename = "pagination")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pagination: Option<models::Pagination>,

    #[serde(rename = "links")]
    pub links: models::CollectionLinks,

}

impl ClientCollection {
    #[allow(clippy::new_without_default)]
    pub fn new(clients: Vec<models::Client>, links: models::CollectionLinks, ) -> ClientCollection {
        ClientCollection {
            clients,
            pagination: None,
            links,
        }
    }
}

/// Converts the ClientCollection value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ClientCollection {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping clients in query parameter serialization

            // Skipping pagination in query parameter serialization

            // Skipping links in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ClientCollection value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ClientCollection {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub clients: Vec<Vec<models::Client>>,
            pub pagination: Vec<models::Pagination>,
            pub links: Vec<models::CollectionLinks>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ClientCollection".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "clients" => return std::result::Result::Err("Parsing a container in this style is not supported in ClientCollection".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "pagination" => intermediate_rep.pagination.push(<models::Pagination as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "links" => intermediate_rep.links.push(<models::CollectionLinks as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ClientCollection".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ClientCollection {
            clients: intermediate_rep.clients.into_iter().next().ok_or_else(|| "clients missing in ClientCollection".to_string())?,
            pagination: intermediate_rep.pagination.into_iter().next(),
            links: intermediate_rep.links.into_iter().next().ok_or_else(|| "links missing in ClientCollection".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ClientCollection> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ClientCollection>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ClientCollection>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ClientCollection - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ClientCollection> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ClientCollection as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ClientCollection - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// A set of client specific options
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ClientOptions {
    /// Grant the client access to verify authorization on behalf of any user.
    #[serde(rename = "grantUserPermissionsAccess")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub grant_user_permissions_access: Option<swagger::Nullable<bool>>,

    /// Grant the client access to generate oauth tokens on behalf of the Authress account. **Security Warning**: This means that this client can impersonate any user, and should only be used when connecting an existing custom Authorization Server to Authress, when that server does not support a standard OAuth connection.
    #[serde(rename = "grantTokenGeneration")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub grant_token_generation: Option<swagger::Nullable<bool>>,

}

impl ClientOptions {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ClientOptions {
        ClientOptions {
            grant_user_permissions_access: Some(swagger::Nullable::Present(false)),
            grant_token_generation: Some(swagger::Nullable::Present(false)),
        }
    }
}

/// Converts the ClientOptions value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ClientOptions {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.grant_user_permissions_access.as_ref().map(|grant_user_permissions_access| {
                vec![
                    "grantUserPermissionsAccess".to_string(),
                    grant_user_permissions_access.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.grant_token_generation.as_ref().map(|grant_token_generation| {
                vec![
                    "grantTokenGeneration".to_string(),
                    grant_token_generation.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ClientOptions value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ClientOptions {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub grant_user_permissions_access: Vec<bool>,
            pub grant_token_generation: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ClientOptions".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "grantUserPermissionsAccess" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ClientOptions".to_string()),
                    "grantTokenGeneration" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ClientOptions".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ClientOptions".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ClientOptions {
            grant_user_permissions_access: std::result::Result::Err("Nullable types not supported in ClientOptions".to_string())?,
            grant_token_generation: std::result::Result::Err("Nullable types not supported in ClientOptions".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ClientOptions> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ClientOptions>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ClientOptions>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ClientOptions - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ClientOptions> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ClientOptions as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ClientOptions - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CollectionLinks {
    #[serde(rename = "self")]
    pub param_self: swagger::Nullable<models::Link>,

    #[serde(rename = "next")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<swagger::Nullable<models::Link>>,

}

impl CollectionLinks {
    #[allow(clippy::new_without_default)]
    pub fn new(param_self: swagger::Nullable<models::Link>, ) -> CollectionLinks {
        CollectionLinks {
            param_self,
            next: None,
        }
    }
}

/// Converts the CollectionLinks value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CollectionLinks {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping self in query parameter serialization

            // Skipping next in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CollectionLinks value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CollectionLinks {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub param_self: Vec<models::Link>,
            pub next: Vec<models::Link>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CollectionLinks".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "self" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CollectionLinks".to_string()),
                    "next" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CollectionLinks".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CollectionLinks".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CollectionLinks {
            param_self: std::result::Result::Err("Nullable types not supported in CollectionLinks".to_string())?,
            next: std::result::Result::Err("Nullable types not supported in CollectionLinks".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CollectionLinks> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CollectionLinks>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CollectionLinks>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CollectionLinks - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CollectionLinks> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CollectionLinks as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CollectionLinks - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Connection {
    // Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<String>,

    #[serde(rename = "connectionId")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub connection_id: Option<swagger::Nullable<String>>,

    #[serde(rename = "authenticationUrl")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub authentication_url: Option<String>,

    #[serde(rename = "tokenUrl")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub token_url: Option<swagger::Nullable<String>>,

    #[serde(rename = "issuerUrl")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub issuer_url: Option<swagger::Nullable<String>>,

    #[serde(rename = "providerCertificate")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub provider_certificate: Option<swagger::Nullable<String>>,

    #[serde(rename = "clientId")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub client_id: Option<swagger::Nullable<String>>,

    #[serde(rename = "clientSecret")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub client_secret: Option<swagger::Nullable<String>>,

    #[serde(rename = "data")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub data: Option<swagger::Nullable<models::ConnectionData>>,

    #[serde(rename = "defaultConnectionProperties")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_connection_properties: Option<swagger::Nullable<models::ConnectionDefaultConnectionProperties>>,

    #[serde(rename = "createdTime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_time: Option<chrono::DateTime::<chrono::Utc>>,

    /// The tags associated with this resource, this property is an map. { key1: value1, key2: value2 }
    #[serde(rename = "tags")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags: Option<swagger::Nullable<std::collections::HashMap<String, String>>>,

}

impl Connection {
    #[allow(clippy::new_without_default)]
    pub fn new() -> Connection {
        Connection {
            r#type: Some("OAUTH2".to_string()),
            connection_id: None,
            authentication_url: None,
            token_url: None,
            issuer_url: None,
            provider_certificate: None,
            client_id: None,
            client_secret: None,
            data: None,
            default_connection_properties: None,
            created_time: None,
            tags: None,
        }
    }
}

/// Converts the Connection value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Connection {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.r#type.as_ref().map(|r#type| {
                vec![
                    "type".to_string(),
                    r#type.to_string(),
                ].join(",")
            }),


            self.connection_id.as_ref().map(|connection_id| {
                vec![
                    "connectionId".to_string(),
                    connection_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.authentication_url.as_ref().map(|authentication_url| {
                vec![
                    "authenticationUrl".to_string(),
                    authentication_url.to_string(),
                ].join(",")
            }),


            self.token_url.as_ref().map(|token_url| {
                vec![
                    "tokenUrl".to_string(),
                    token_url.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.issuer_url.as_ref().map(|issuer_url| {
                vec![
                    "issuerUrl".to_string(),
                    issuer_url.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.provider_certificate.as_ref().map(|provider_certificate| {
                vec![
                    "providerCertificate".to_string(),
                    provider_certificate.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.client_id.as_ref().map(|client_id| {
                vec![
                    "clientId".to_string(),
                    client_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.client_secret.as_ref().map(|client_secret| {
                vec![
                    "clientSecret".to_string(),
                    client_secret.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping data in query parameter serialization

            // Skipping defaultConnectionProperties in query parameter serialization

            // Skipping createdTime in query parameter serialization

            // Skipping tags in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Connection value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Connection {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<String>,
            pub connection_id: Vec<String>,
            pub authentication_url: Vec<String>,
            pub token_url: Vec<String>,
            pub issuer_url: Vec<String>,
            pub provider_certificate: Vec<String>,
            pub client_id: Vec<String>,
            pub client_secret: Vec<String>,
            pub data: Vec<models::ConnectionData>,
            pub default_connection_properties: Vec<models::ConnectionDefaultConnectionProperties>,
            pub created_time: Vec<chrono::DateTime::<chrono::Utc>>,
            pub tags: Vec<std::collections::HashMap<String, String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Connection".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "connectionId" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Connection".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "authenticationUrl" => intermediate_rep.authentication_url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "tokenUrl" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Connection".to_string()),
                    "issuerUrl" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Connection".to_string()),
                    "providerCertificate" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Connection".to_string()),
                    "clientId" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Connection".to_string()),
                    "clientSecret" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Connection".to_string()),
                    "data" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Connection".to_string()),
                    "defaultConnectionProperties" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Connection".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "createdTime" => intermediate_rep.created_time.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "tags" => return std::result::Result::Err("Parsing a container in this style is not supported in Connection".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing Connection".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Connection {
            r#type: intermediate_rep.r#type.into_iter().next(),
            connection_id: std::result::Result::Err("Nullable types not supported in Connection".to_string())?,
            authentication_url: intermediate_rep.authentication_url.into_iter().next(),
            token_url: std::result::Result::Err("Nullable types not supported in Connection".to_string())?,
            issuer_url: std::result::Result::Err("Nullable types not supported in Connection".to_string())?,
            provider_certificate: std::result::Result::Err("Nullable types not supported in Connection".to_string())?,
            client_id: std::result::Result::Err("Nullable types not supported in Connection".to_string())?,
            client_secret: std::result::Result::Err("Nullable types not supported in Connection".to_string())?,
            data: std::result::Result::Err("Nullable types not supported in Connection".to_string())?,
            default_connection_properties: std::result::Result::Err("Nullable types not supported in Connection".to_string())?,
            created_time: intermediate_rep.created_time.into_iter().next(),
            tags: std::result::Result::Err("Nullable types not supported in Connection".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Connection> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Connection>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Connection>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Connection - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Connection> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Connection as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Connection - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// A collection of connections.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ConnectionCollection {
    #[serde(rename = "connections")]
    pub connections: Vec<models::Connection>,

    #[serde(rename = "pagination")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pagination: Option<models::Pagination>,

}

impl ConnectionCollection {
    #[allow(clippy::new_without_default)]
    pub fn new(connections: Vec<models::Connection>, ) -> ConnectionCollection {
        ConnectionCollection {
            connections,
            pagination: None,
        }
    }
}

/// Converts the ConnectionCollection value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ConnectionCollection {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping connections in query parameter serialization

            // Skipping pagination in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ConnectionCollection value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ConnectionCollection {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub connections: Vec<Vec<models::Connection>>,
            pub pagination: Vec<models::Pagination>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ConnectionCollection".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "connections" => return std::result::Result::Err("Parsing a container in this style is not supported in ConnectionCollection".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "pagination" => intermediate_rep.pagination.push(<models::Pagination as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ConnectionCollection".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ConnectionCollection {
            connections: intermediate_rep.connections.into_iter().next().ok_or_else(|| "connections missing in ConnectionCollection".to_string())?,
            pagination: intermediate_rep.pagination.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ConnectionCollection> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ConnectionCollection>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ConnectionCollection>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ConnectionCollection - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ConnectionCollection> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ConnectionCollection as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ConnectionCollection - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ConnectionData {
    #[serde(rename = "tenantId")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tenant_id: Option<swagger::Nullable<String>>,

    #[serde(rename = "name")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<swagger::Nullable<String>>,

    // Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "supportedContentType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub supported_content_type: Option<String>,

}

impl ConnectionData {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ConnectionData {
        ConnectionData {
            tenant_id: None,
            name: None,
            supported_content_type: Some("application/json".to_string()),
        }
    }
}

/// Converts the ConnectionData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ConnectionData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.tenant_id.as_ref().map(|tenant_id| {
                vec![
                    "tenantId".to_string(),
                    tenant_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                vec![
                    "name".to_string(),
                    name.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.supported_content_type.as_ref().map(|supported_content_type| {
                vec![
                    "supportedContentType".to_string(),
                    supported_content_type.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ConnectionData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ConnectionData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub tenant_id: Vec<String>,
            pub name: Vec<String>,
            pub supported_content_type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ConnectionData".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "tenantId" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ConnectionData".to_string()),
                    "name" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ConnectionData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "supportedContentType" => intermediate_rep.supported_content_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ConnectionData".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ConnectionData {
            tenant_id: std::result::Result::Err("Nullable types not supported in ConnectionData".to_string())?,
            name: std::result::Result::Err("Nullable types not supported in ConnectionData".to_string())?,
            supported_content_type: intermediate_rep.supported_content_type.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ConnectionData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ConnectionData>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ConnectionData>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ConnectionData - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ConnectionData> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ConnectionData as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ConnectionData - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ConnectionDefaultConnectionProperties {
    #[serde(rename = "scope")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub scope: Option<swagger::Nullable<String>>,

}

impl ConnectionDefaultConnectionProperties {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ConnectionDefaultConnectionProperties {
        ConnectionDefaultConnectionProperties {
            scope: Some(swagger::Nullable::Present("profile email openid".to_string())),
        }
    }
}

/// Converts the ConnectionDefaultConnectionProperties value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ConnectionDefaultConnectionProperties {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.scope.as_ref().map(|scope| {
                vec![
                    "scope".to_string(),
                    scope.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ConnectionDefaultConnectionProperties value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ConnectionDefaultConnectionProperties {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub scope: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ConnectionDefaultConnectionProperties".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "scope" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ConnectionDefaultConnectionProperties".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ConnectionDefaultConnectionProperties".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ConnectionDefaultConnectionProperties {
            scope: std::result::Result::Err("Nullable types not supported in ConnectionDefaultConnectionProperties".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ConnectionDefaultConnectionProperties> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ConnectionDefaultConnectionProperties>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ConnectionDefaultConnectionProperties>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ConnectionDefaultConnectionProperties - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ConnectionDefaultConnectionProperties> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ConnectionDefaultConnectionProperties as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ConnectionDefaultConnectionProperties - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Extension {
    #[serde(rename = "extensionId")]
    pub extension_id: String,

    /// The name of the extension. This name is visible in the Authress management portal
    #[serde(rename = "name")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<swagger::Nullable<String>>,

    #[serde(rename = "createdTime")]
    pub created_time: chrono::DateTime::<chrono::Utc>,

    #[serde(rename = "application")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub application: Option<models::ExtensionApplication>,

    #[serde(rename = "client")]
    pub client: models::ExtensionClient,

    /// The tags associated with this resource, this property is an map. { key1: value1, key2: value2 }
    #[serde(rename = "tags")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags: Option<swagger::Nullable<std::collections::HashMap<String, String>>>,

}

impl Extension {
    #[allow(clippy::new_without_default)]
    pub fn new(extension_id: String, created_time: chrono::DateTime::<chrono::Utc>, client: models::ExtensionClient, ) -> Extension {
        Extension {
            extension_id,
            name: None,
            created_time,
            application: None,
            client,
            tags: None,
        }
    }
}

/// Converts the Extension value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Extension {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("extensionId".to_string()),
            Some(self.extension_id.to_string()),


            self.name.as_ref().map(|name| {
                vec![
                    "name".to_string(),
                    name.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping createdTime in query parameter serialization

            // Skipping application in query parameter serialization

            // Skipping client in query parameter serialization

            // Skipping tags in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Extension value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Extension {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub extension_id: Vec<String>,
            pub name: Vec<String>,
            pub created_time: Vec<chrono::DateTime::<chrono::Utc>>,
            pub application: Vec<models::ExtensionApplication>,
            pub client: Vec<models::ExtensionClient>,
            pub tags: Vec<std::collections::HashMap<String, String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Extension".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "extensionId" => intermediate_rep.extension_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "name" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Extension".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "createdTime" => intermediate_rep.created_time.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "application" => intermediate_rep.application.push(<models::ExtensionApplication as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "client" => intermediate_rep.client.push(<models::ExtensionClient as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "tags" => return std::result::Result::Err("Parsing a container in this style is not supported in Extension".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing Extension".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Extension {
            extension_id: intermediate_rep.extension_id.into_iter().next().ok_or_else(|| "extensionId missing in Extension".to_string())?,
            name: std::result::Result::Err("Nullable types not supported in Extension".to_string())?,
            created_time: intermediate_rep.created_time.into_iter().next().ok_or_else(|| "createdTime missing in Extension".to_string())?,
            application: intermediate_rep.application.into_iter().next(),
            client: intermediate_rep.client.into_iter().next().ok_or_else(|| "client missing in Extension".to_string())?,
            tags: std::result::Result::Err("Nullable types not supported in Extension".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Extension> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Extension>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Extension>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Extension - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Extension> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Extension as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Extension - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// The extension's application configuration. The application contains the necessary information for users to log in to the extension.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ExtensionApplication {
    /// The unique ID of the application.
    #[serde(rename = "applicationId")]
    pub application_id: String,

    #[serde(rename = "redirectUrls")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub redirect_urls: Option<swagger::Nullable<Vec<String>>>,

    #[serde(rename = "links")]
    pub links: models::Links,

}

impl ExtensionApplication {
    #[allow(clippy::new_without_default)]
    pub fn new(application_id: String, links: models::Links, ) -> ExtensionApplication {
        ExtensionApplication {
            application_id,
            redirect_urls: None,
            links,
        }
    }
}

/// Converts the ExtensionApplication value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ExtensionApplication {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("applicationId".to_string()),
            Some(self.application_id.to_string()),


            self.redirect_urls.as_ref().map(|redirect_urls| {
                vec![
                    "redirectUrls".to_string(),
                    redirect_urls.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

            // Skipping links in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ExtensionApplication value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ExtensionApplication {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub application_id: Vec<String>,
            pub redirect_urls: Vec<Vec<String>>,
            pub links: Vec<models::Links>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ExtensionApplication".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "applicationId" => intermediate_rep.application_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "redirectUrls" => return std::result::Result::Err("Parsing a container in this style is not supported in ExtensionApplication".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "links" => intermediate_rep.links.push(<models::Links as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ExtensionApplication".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ExtensionApplication {
            application_id: intermediate_rep.application_id.into_iter().next().ok_or_else(|| "applicationId missing in ExtensionApplication".to_string())?,
            redirect_urls: std::result::Result::Err("Nullable types not supported in ExtensionApplication".to_string())?,
            links: intermediate_rep.links.into_iter().next().ok_or_else(|| "links missing in ExtensionApplication".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ExtensionApplication> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ExtensionApplication>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ExtensionApplication>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ExtensionApplication - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ExtensionApplication> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ExtensionApplication as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ExtensionApplication - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// The extension's client configuration.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ExtensionClient {
    /// The unique ID of the client.
    #[serde(rename = "clientId")]
    pub client_id: String,

    #[serde(rename = "links")]
    pub links: models::Links,

}

impl ExtensionClient {
    #[allow(clippy::new_without_default)]
    pub fn new(client_id: String, links: models::Links, ) -> ExtensionClient {
        ExtensionClient {
            client_id,
            links,
        }
    }
}

/// Converts the ExtensionClient value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ExtensionClient {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("clientId".to_string()),
            Some(self.client_id.to_string()),

            // Skipping links in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ExtensionClient value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ExtensionClient {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub client_id: Vec<String>,
            pub links: Vec<models::Links>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ExtensionClient".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "clientId" => intermediate_rep.client_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "links" => intermediate_rep.links.push(<models::Links as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ExtensionClient".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ExtensionClient {
            client_id: intermediate_rep.client_id.into_iter().next().ok_or_else(|| "clientId missing in ExtensionClient".to_string())?,
            links: intermediate_rep.links.into_iter().next().ok_or_else(|| "links missing in ExtensionClient".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ExtensionClient> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ExtensionClient>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ExtensionClient>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ExtensionClient - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ExtensionClient> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ExtensionClient as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ExtensionClient - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// A collection of platform extensions.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ExtensionCollection {
    #[serde(rename = "extensions")]
    pub extensions: Vec<models::Extension>,

    #[serde(rename = "pagination")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pagination: Option<models::Pagination>,

}

impl ExtensionCollection {
    #[allow(clippy::new_without_default)]
    pub fn new(extensions: Vec<models::Extension>, ) -> ExtensionCollection {
        ExtensionCollection {
            extensions,
            pagination: None,
        }
    }
}

/// Converts the ExtensionCollection value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ExtensionCollection {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping extensions in query parameter serialization

            // Skipping pagination in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ExtensionCollection value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ExtensionCollection {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub extensions: Vec<Vec<models::Extension>>,
            pub pagination: Vec<models::Pagination>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ExtensionCollection".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "extensions" => return std::result::Result::Err("Parsing a container in this style is not supported in ExtensionCollection".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "pagination" => intermediate_rep.pagination.push(<models::Pagination as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ExtensionCollection".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ExtensionCollection {
            extensions: intermediate_rep.extensions.into_iter().next().ok_or_else(|| "extensions missing in ExtensionCollection".to_string())?,
            pagination: intermediate_rep.pagination.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ExtensionCollection> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ExtensionCollection>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ExtensionCollection>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ExtensionCollection - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ExtensionCollection> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ExtensionCollection as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ExtensionCollection - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// A group of users, which can be added to access records.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Group {
    /// Unique identifier for the groupId, can be specified on record creation. Must begin with grp_.
    #[serde(rename = "groupId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub group_id: Option<String>,

    /// A helpful name for this record
    #[serde(rename = "name")]
    pub name: String,

    /// The expected last time the group was updated
    #[serde(rename = "lastUpdated")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_updated: Option<chrono::DateTime::<chrono::Utc>>,

    /// The list of users in this group
    #[serde(rename = "users")]
    pub users: Vec<models::User>,

    /// The list of admins that can edit this record even if they do not have global record edit permissions.
    #[serde(rename = "admins")]
    pub admins: Vec<models::User>,

    #[serde(rename = "links")]
    pub links: models::AccountLinks,

    /// The tags associated with this resource, this property is an map. { key1: value1, key2: value2 }
    #[serde(rename = "tags")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags: Option<swagger::Nullable<std::collections::HashMap<String, String>>>,

}

impl Group {
    #[allow(clippy::new_without_default)]
    pub fn new(name: String, users: Vec<models::User>, admins: Vec<models::User>, links: models::AccountLinks, ) -> Group {
        Group {
            group_id: None,
            name,
            last_updated: None,
            users,
            admins,
            links,
            tags: None,
        }
    }
}

/// Converts the Group value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Group {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.group_id.as_ref().map(|group_id| {
                vec![
                    "groupId".to_string(),
                    group_id.to_string(),
                ].join(",")
            }),


            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping lastUpdated in query parameter serialization

            // Skipping users in query parameter serialization

            // Skipping admins in query parameter serialization

            // Skipping links in query parameter serialization

            // Skipping tags in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Group value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Group {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub group_id: Vec<String>,
            pub name: Vec<String>,
            pub last_updated: Vec<chrono::DateTime::<chrono::Utc>>,
            pub users: Vec<Vec<models::User>>,
            pub admins: Vec<Vec<models::User>>,
            pub links: Vec<models::AccountLinks>,
            pub tags: Vec<std::collections::HashMap<String, String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Group".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "groupId" => intermediate_rep.group_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lastUpdated" => intermediate_rep.last_updated.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "users" => return std::result::Result::Err("Parsing a container in this style is not supported in Group".to_string()),
                    "admins" => return std::result::Result::Err("Parsing a container in this style is not supported in Group".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "links" => intermediate_rep.links.push(<models::AccountLinks as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "tags" => return std::result::Result::Err("Parsing a container in this style is not supported in Group".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing Group".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Group {
            group_id: intermediate_rep.group_id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in Group".to_string())?,
            last_updated: intermediate_rep.last_updated.into_iter().next(),
            users: intermediate_rep.users.into_iter().next().ok_or_else(|| "users missing in Group".to_string())?,
            admins: intermediate_rep.admins.into_iter().next().ok_or_else(|| "admins missing in Group".to_string())?,
            links: intermediate_rep.links.into_iter().next().ok_or_else(|| "links missing in Group".to_string())?,
            tags: std::result::Result::Err("Nullable types not supported in Group".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Group> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Group>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Group>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Group - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Group> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Group as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Group - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// A collection of groups
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GroupCollection {
    /// A list of groups
    #[serde(rename = "groups")]
    pub groups: Vec<models::Group>,

    #[serde(rename = "pagination")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pagination: Option<models::Pagination>,

    #[serde(rename = "links")]
    pub links: models::CollectionLinks,

}

impl GroupCollection {
    #[allow(clippy::new_without_default)]
    pub fn new(groups: Vec<models::Group>, links: models::CollectionLinks, ) -> GroupCollection {
        GroupCollection {
            groups,
            pagination: None,
            links,
        }
    }
}

/// Converts the GroupCollection value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GroupCollection {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping groups in query parameter serialization

            // Skipping pagination in query parameter serialization

            // Skipping links in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GroupCollection value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GroupCollection {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub groups: Vec<Vec<models::Group>>,
            pub pagination: Vec<models::Pagination>,
            pub links: Vec<models::CollectionLinks>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GroupCollection".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "groups" => return std::result::Result::Err("Parsing a container in this style is not supported in GroupCollection".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "pagination" => intermediate_rep.pagination.push(<models::Pagination as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "links" => intermediate_rep.links.push(<models::CollectionLinks as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GroupCollection".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GroupCollection {
            groups: intermediate_rep.groups.into_iter().next().ok_or_else(|| "groups missing in GroupCollection".to_string())?,
            pagination: intermediate_rep.pagination.into_iter().next(),
            links: intermediate_rep.links.into_iter().next().ok_or_else(|| "links missing in GroupCollection".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GroupCollection> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GroupCollection>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GroupCollection>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GroupCollection - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GroupCollection> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GroupCollection as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GroupCollection - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// The identifying information which uniquely links a JWT OIDC token to an identity provider
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Identity {
    /// The issuer of the JWT token. This can be any OIDC compliant provider.
    #[serde(rename = "issuer")]
    pub issuer: String,

    /// The audience of the JWT token. This can be either an audience for your entire app, or one particular audience for it. If there is more than one audience, multiple identities can be created.
    #[serde(rename = "audience")]
    pub audience: String,

}

impl Identity {
    #[allow(clippy::new_without_default)]
    pub fn new(issuer: String, audience: String, ) -> Identity {
        Identity {
            issuer,
            audience,
        }
    }
}

/// Converts the Identity value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Identity {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("issuer".to_string()),
            Some(self.issuer.to_string()),


            Some("audience".to_string()),
            Some(self.audience.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Identity value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Identity {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub issuer: Vec<String>,
            pub audience: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Identity".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "issuer" => intermediate_rep.issuer.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "audience" => intermediate_rep.audience.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Identity".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Identity {
            issuer: intermediate_rep.issuer.into_iter().next().ok_or_else(|| "issuer missing in Identity".to_string())?,
            audience: intermediate_rep.audience.into_iter().next().ok_or_else(|| "audience missing in Identity".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Identity> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Identity>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Identity>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Identity - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Identity> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Identity as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Identity - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct IdentityCollection {
    #[serde(rename = "identities")]
    pub identities: Vec<models::Identity>,

}

impl IdentityCollection {
    #[allow(clippy::new_without_default)]
    pub fn new(identities: Vec<models::Identity>, ) -> IdentityCollection {
        IdentityCollection {
            identities,
        }
    }
}

/// Converts the IdentityCollection value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for IdentityCollection {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping identities in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a IdentityCollection value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for IdentityCollection {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub identities: Vec<Vec<models::Identity>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing IdentityCollection".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "identities" => return std::result::Result::Err("Parsing a container in this style is not supported in IdentityCollection".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing IdentityCollection".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(IdentityCollection {
            identities: intermediate_rep.identities.into_iter().next().ok_or_else(|| "identities missing in IdentityCollection".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<IdentityCollection> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<IdentityCollection>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<IdentityCollection>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for IdentityCollection - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<IdentityCollection> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <IdentityCollection as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into IdentityCollection - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Request to link an identity provider's audience and your app's audience with Authress.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct IdentityRequest {
    /// A valid JWT OIDC compliant token which will still pass authentication requests to the identity provider. Must contain a unique audience and issuer.
    #[serde(rename = "jwt")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub jwt: Option<swagger::Nullable<String>>,

    /// The issuer of the OAuth OIDC provider's JWTs. This value should match the `iss` claim in the provided tokens exactly.
    #[serde(rename = "issuer")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub issuer: Option<swagger::Nullable<String>>,

    /// If the `jwt` token contains more than one valid audience, then the single audience that should associated with Authress. If more than one audience is preferred, repeat this call with each one.
    #[serde(rename = "preferredAudience")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub preferred_audience: Option<swagger::Nullable<String>>,

}

impl IdentityRequest {
    #[allow(clippy::new_without_default)]
    pub fn new() -> IdentityRequest {
        IdentityRequest {
            jwt: None,
            issuer: None,
            preferred_audience: Some(swagger::Nullable::Present("*".to_string())),
        }
    }
}

/// Converts the IdentityRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for IdentityRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.jwt.as_ref().map(|jwt| {
                vec![
                    "jwt".to_string(),
                    jwt.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.issuer.as_ref().map(|issuer| {
                vec![
                    "issuer".to_string(),
                    issuer.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.preferred_audience.as_ref().map(|preferred_audience| {
                vec![
                    "preferredAudience".to_string(),
                    preferred_audience.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a IdentityRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for IdentityRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub jwt: Vec<String>,
            pub issuer: Vec<String>,
            pub preferred_audience: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing IdentityRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "jwt" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in IdentityRequest".to_string()),
                    "issuer" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in IdentityRequest".to_string()),
                    "preferredAudience" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in IdentityRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing IdentityRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(IdentityRequest {
            jwt: std::result::Result::Err("Nullable types not supported in IdentityRequest".to_string())?,
            issuer: std::result::Result::Err("Nullable types not supported in IdentityRequest".to_string())?,
            preferred_audience: std::result::Result::Err("Nullable types not supported in IdentityRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<IdentityRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<IdentityRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<IdentityRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for IdentityRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<IdentityRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <IdentityRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into IdentityRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// The user invite used to invite users to your application or to Authress as an admin.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Invite {
    /// The unique identifier for the invite. Use this ID to accept the invite.
    #[serde(rename = "inviteId")]
    pub invite_id: String,

    /// A list of statements which match roles to resources. The invited user will all statements apply to them
    #[serde(rename = "statements")]
    pub statements: Vec<models::Statement>,

    #[serde(rename = "links")]
    pub links: models::AccountLinks,

}

impl Invite {
    #[allow(clippy::new_without_default)]
    pub fn new(invite_id: String, statements: Vec<models::Statement>, links: models::AccountLinks, ) -> Invite {
        Invite {
            invite_id,
            statements,
            links,
        }
    }
}

/// Converts the Invite value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Invite {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("inviteId".to_string()),
            Some(self.invite_id.to_string()),

            // Skipping statements in query parameter serialization

            // Skipping links in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Invite value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Invite {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub invite_id: Vec<String>,
            pub statements: Vec<Vec<models::Statement>>,
            pub links: Vec<models::AccountLinks>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Invite".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "inviteId" => intermediate_rep.invite_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "statements" => return std::result::Result::Err("Parsing a container in this style is not supported in Invite".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "links" => intermediate_rep.links.push(<models::AccountLinks as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Invite".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Invite {
            invite_id: intermediate_rep.invite_id.into_iter().next().ok_or_else(|| "inviteId missing in Invite".to_string())?,
            statements: intermediate_rep.statements.into_iter().next().ok_or_else(|| "statements missing in Invite".to_string())?,
            links: intermediate_rep.links.into_iter().next().ok_or_else(|| "links missing in Invite".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Invite> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Invite>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Invite>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Invite - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Invite> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Invite as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Invite - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// A url linking object that complies to application/links+json RFC. Either is an IANA approved link relation or has a custom rel specified.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Link {
    /// The absolute url pointing to the reference resource.
    #[serde(rename = "href")]
    pub href: String,

    /// Optional property indicating the type of link if it is not a default IANA approved global link relation.
    #[serde(rename = "rel")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rel: Option<String>,

}

impl Link {
    #[allow(clippy::new_without_default)]
    pub fn new(href: String, ) -> Link {
        Link {
            href,
            rel: None,
        }
    }
}

/// Converts the Link value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Link {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("href".to_string()),
            Some(self.href.to_string()),


            self.rel.as_ref().map(|rel| {
                vec![
                    "rel".to_string(),
                    rel.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Link value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Link {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub href: Vec<String>,
            pub rel: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Link".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "href" => intermediate_rep.href.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "rel" => intermediate_rep.rel.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Link".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Link {
            href: intermediate_rep.href.into_iter().next().ok_or_else(|| "href missing in Link".to_string())?,
            rel: intermediate_rep.rel.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Link> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Link>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Link>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Link - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Link> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Link as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Link - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// The referenced group
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LinkedGroup {
    #[serde(rename = "groupId")]
    pub group_id: String,

}

impl LinkedGroup {
    #[allow(clippy::new_without_default)]
    pub fn new(group_id: String, ) -> LinkedGroup {
        LinkedGroup {
            group_id,
        }
    }
}

/// Converts the LinkedGroup value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for LinkedGroup {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping groupId in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LinkedGroup value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LinkedGroup {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub group_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LinkedGroup".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "groupId" => intermediate_rep.group_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing LinkedGroup".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LinkedGroup {
            group_id: intermediate_rep.group_id.into_iter().next().ok_or_else(|| "groupId missing in LinkedGroup".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LinkedGroup> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<LinkedGroup>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LinkedGroup>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for LinkedGroup - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<LinkedGroup> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LinkedGroup as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into LinkedGroup - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Links {
    #[serde(rename = "self")]
    pub param_self: swagger::Nullable<models::Link>,

}

impl Links {
    #[allow(clippy::new_without_default)]
    pub fn new(param_self: swagger::Nullable<models::Link>, ) -> Links {
        Links {
            param_self,
        }
    }
}

/// Converts the Links value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Links {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping self in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Links value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Links {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub param_self: Vec<models::Link>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Links".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "self" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Links".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing Links".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Links {
            param_self: std::result::Result::Err("Nullable types not supported in Links".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Links> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Links>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Links>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Links - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Links> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Links as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Links - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Metadata and additional properties relevant.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MetadataObject {
    #[serde(rename = "account")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub account: Option<models::MetadataObjectAccount>,

    #[serde(rename = "userId")]
    pub user_id: String,

    /// A JSON object limited to 10KB. The owner identified by the sub will always have access to read and update this data. Service clients may have access if the related property on the client is set. Access is restricted to authorized users.
    #[serde(rename = "metadata")]
    pub metadata: serde_json::Value,

}

impl MetadataObject {
    #[allow(clippy::new_without_default)]
    pub fn new(user_id: String, metadata: serde_json::Value, ) -> MetadataObject {
        MetadataObject {
            account: None,
            user_id,
            metadata,
        }
    }
}

/// Converts the MetadataObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for MetadataObject {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping account in query parameter serialization

            // Skipping userId in query parameter serialization

            // Skipping metadata in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MetadataObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MetadataObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub account: Vec<models::MetadataObjectAccount>,
            pub user_id: Vec<String>,
            pub metadata: Vec<serde_json::Value>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MetadataObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "account" => intermediate_rep.account.push(<models::MetadataObjectAccount as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "userId" => intermediate_rep.user_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "metadata" => intermediate_rep.metadata.push(<serde_json::Value as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MetadataObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MetadataObject {
            account: intermediate_rep.account.into_iter().next(),
            user_id: intermediate_rep.user_id.into_iter().next().ok_or_else(|| "userId missing in MetadataObject".to_string())?,
            metadata: intermediate_rep.metadata.into_iter().next().ok_or_else(|| "metadata missing in MetadataObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MetadataObject> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<MetadataObject>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MetadataObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MetadataObject - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<MetadataObject> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MetadataObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MetadataObject - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MetadataObjectAccount {
    #[serde(rename = "accountId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub account_id: Option<String>,

}

impl MetadataObjectAccount {
    #[allow(clippy::new_without_default)]
    pub fn new() -> MetadataObjectAccount {
        MetadataObjectAccount {
            account_id: None,
        }
    }
}

/// Converts the MetadataObjectAccount value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for MetadataObjectAccount {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.account_id.as_ref().map(|account_id| {
                vec![
                    "accountId".to_string(),
                    account_id.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MetadataObjectAccount value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MetadataObjectAccount {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub account_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MetadataObjectAccount".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "accountId" => intermediate_rep.account_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MetadataObjectAccount".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MetadataObjectAccount {
            account_id: intermediate_rep.account_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MetadataObjectAccount> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<MetadataObjectAccount>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MetadataObjectAccount>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MetadataObjectAccount - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<MetadataObjectAccount> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MetadataObjectAccount as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MetadataObjectAccount - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OAuthAuthorizeResponse {
    /// The authorization code to be used with the /tokens endpoint to retrieve an access_token.
    #[serde(rename = "code")]
    pub code: String,

}

impl OAuthAuthorizeResponse {
    #[allow(clippy::new_without_default)]
    pub fn new(code: String, ) -> OAuthAuthorizeResponse {
        OAuthAuthorizeResponse {
            code,
        }
    }
}

/// Converts the OAuthAuthorizeResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OAuthAuthorizeResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("code".to_string()),
            Some(self.code.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OAuthAuthorizeResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OAuthAuthorizeResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub code: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OAuthAuthorizeResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "code" => intermediate_rep.code.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OAuthAuthorizeResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OAuthAuthorizeResponse {
            code: intermediate_rep.code.into_iter().next().ok_or_else(|| "code missing in OAuthAuthorizeResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OAuthAuthorizeResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OAuthAuthorizeResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OAuthAuthorizeResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OAuthAuthorizeResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OAuthAuthorizeResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OAuthAuthorizeResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OAuthAuthorizeResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// The OAuth 2.1 token request that follows [RFC 6749](https://www.rfc-editor.org/rfc/rfc6749). The properties in the request must be snake_case to follow the standard.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OAuthTokenRequest {
    /// The client identifier to constrain the token to.
    #[serde(rename = "client_id")]
    pub client_id: String,

    /// The secret associated with the client that authorizes the generation of token it's behalf. (Either the `client_secret` or the `code_verifier` is required)
    #[serde(rename = "client_secret")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub client_secret: Option<swagger::Nullable<String>>,

    /// The code verifier is the the value used in the generation of the OAuth authorization request `code_challenge` property. (Either the `client_secret` or the `code_verifier` is required)
    #[serde(rename = "code_verifier")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub code_verifier: Option<String>,

    /// A suggestion to the token generation which type of credentials are being provided.
    // Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "grant_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub grant_type: Option<String>,

    /// When using the user password grant_type, specify the username. Authress recommends this should always be an email address.
    #[serde(rename = "username")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub username: Option<swagger::Nullable<String>>,

    /// When using the user password grant_type, specify the user's password.
    #[serde(rename = "password")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub password: Option<swagger::Nullable<String>>,

    /// Enables additional configuration of the grant_type. In the case of user password grant_type, set this to **signup**, to enable the creation of users. Set this to **update**, force update the password associated with the user.
    // Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<swagger::Nullable<String>>,

}

impl OAuthTokenRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(client_id: String, ) -> OAuthTokenRequest {
        OAuthTokenRequest {
            client_id,
            client_secret: None,
            code_verifier: None,
            grant_type: None,
            username: None,
            password: None,
            r#type: None,
        }
    }
}

/// Converts the OAuthTokenRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OAuthTokenRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("client_id".to_string()),
            Some(self.client_id.to_string()),


            self.client_secret.as_ref().map(|client_secret| {
                vec![
                    "client_secret".to_string(),
                    client_secret.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.code_verifier.as_ref().map(|code_verifier| {
                vec![
                    "code_verifier".to_string(),
                    code_verifier.to_string(),
                ].join(",")
            }),


            self.grant_type.as_ref().map(|grant_type| {
                vec![
                    "grant_type".to_string(),
                    grant_type.to_string(),
                ].join(",")
            }),


            self.username.as_ref().map(|username| {
                vec![
                    "username".to_string(),
                    username.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.password.as_ref().map(|password| {
                vec![
                    "password".to_string(),
                    password.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.r#type.as_ref().map(|r#type| {
                vec![
                    "type".to_string(),
                    r#type.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OAuthTokenRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OAuthTokenRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub client_id: Vec<String>,
            pub client_secret: Vec<String>,
            pub code_verifier: Vec<String>,
            pub grant_type: Vec<String>,
            pub username: Vec<String>,
            pub password: Vec<String>,
            pub r#type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OAuthTokenRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "client_id" => intermediate_rep.client_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "client_secret" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in OAuthTokenRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "code_verifier" => intermediate_rep.code_verifier.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "grant_type" => intermediate_rep.grant_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "username" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in OAuthTokenRequest".to_string()),
                    "password" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in OAuthTokenRequest".to_string()),
                    "type" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in OAuthTokenRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing OAuthTokenRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OAuthTokenRequest {
            client_id: intermediate_rep.client_id.into_iter().next().ok_or_else(|| "client_id missing in OAuthTokenRequest".to_string())?,
            client_secret: std::result::Result::Err("Nullable types not supported in OAuthTokenRequest".to_string())?,
            code_verifier: intermediate_rep.code_verifier.into_iter().next(),
            grant_type: intermediate_rep.grant_type.into_iter().next(),
            username: std::result::Result::Err("Nullable types not supported in OAuthTokenRequest".to_string())?,
            password: std::result::Result::Err("Nullable types not supported in OAuthTokenRequest".to_string())?,
            r#type: std::result::Result::Err("Nullable types not supported in OAuthTokenRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OAuthTokenRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OAuthTokenRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OAuthTokenRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OAuthTokenRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OAuthTokenRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OAuthTokenRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OAuthTokenRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OAuthTokenResponse {
    /// An expiring access token that can be used to access either Authress or any platform service.
    #[serde(rename = "access_token")]
    pub access_token: String,

}

impl OAuthTokenResponse {
    #[allow(clippy::new_without_default)]
    pub fn new(access_token: String, ) -> OAuthTokenResponse {
        OAuthTokenResponse {
            access_token,
        }
    }
}

/// Converts the OAuthTokenResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OAuthTokenResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("access_token".to_string()),
            Some(self.access_token.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OAuthTokenResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OAuthTokenResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub access_token: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OAuthTokenResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "access_token" => intermediate_rep.access_token.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OAuthTokenResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OAuthTokenResponse {
            access_token: intermediate_rep.access_token.into_iter().next().ok_or_else(|| "access_token missing in OAuthTokenResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OAuthTokenResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OAuthTokenResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OAuthTokenResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OAuthTokenResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OAuthTokenResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OAuthTokenResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OAuthTokenResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Details containing how to pagination through the collection. Consists of an optional *next* property that may contain a cursor. Pagination is mutable and the list can change between requests.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Pagination {
    #[serde(rename = "next")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<swagger::Nullable<models::PaginationNext>>,

}

impl Pagination {
    #[allow(clippy::new_without_default)]
    pub fn new() -> Pagination {
        Pagination {
            next: None,
        }
    }
}

/// Converts the Pagination value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Pagination {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping next in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Pagination value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Pagination {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub next: Vec<models::PaginationNext>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Pagination".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "next" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Pagination".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing Pagination".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Pagination {
            next: std::result::Result::Err("Nullable types not supported in Pagination".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Pagination> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Pagination>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Pagination>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Pagination - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Pagination> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Pagination as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Pagination - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// A reference to the next page in the collection, pass the cursor as a query parameter in the subsequent request to get the next page.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaginationNext {
    #[serde(rename = "cursor")]
    pub cursor: String,

}

impl PaginationNext {
    #[allow(clippy::new_without_default)]
    pub fn new(cursor: String, ) -> PaginationNext {
        PaginationNext {
            cursor,
        }
    }
}

/// Converts the PaginationNext value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PaginationNext {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("cursor".to_string()),
            Some(self.cursor.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaginationNext value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaginationNext {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub cursor: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaginationNext".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "cursor" => intermediate_rep.cursor.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaginationNext".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaginationNext {
            cursor: intermediate_rep.cursor.into_iter().next().ok_or_else(|| "cursor missing in PaginationNext".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaginationNext> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PaginationNext>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaginationNext>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PaginationNext - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PaginationNext> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaginationNext as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PaginationNext - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// A collect of permissions that the user has to a resource.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PermissionCollection {
    #[serde(rename = "account")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub account: Option<models::PermissionCollectionAccount>,

    #[serde(rename = "userId")]
    pub user_id: String,

    /// A list of the permissions
    #[serde(rename = "permissions")]
    pub permissions: Vec<models::PermissionObject>,

}

impl PermissionCollection {
    #[allow(clippy::new_without_default)]
    pub fn new(user_id: String, permissions: Vec<models::PermissionObject>, ) -> PermissionCollection {
        PermissionCollection {
            account: None,
            user_id,
            permissions,
        }
    }
}

/// Converts the PermissionCollection value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PermissionCollection {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping account in query parameter serialization

            // Skipping userId in query parameter serialization

            // Skipping permissions in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PermissionCollection value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PermissionCollection {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub account: Vec<models::PermissionCollectionAccount>,
            pub user_id: Vec<String>,
            pub permissions: Vec<Vec<models::PermissionObject>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PermissionCollection".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "account" => intermediate_rep.account.push(<models::PermissionCollectionAccount as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "userId" => intermediate_rep.user_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "permissions" => return std::result::Result::Err("Parsing a container in this style is not supported in PermissionCollection".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PermissionCollection".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PermissionCollection {
            account: intermediate_rep.account.into_iter().next(),
            user_id: intermediate_rep.user_id.into_iter().next().ok_or_else(|| "userId missing in PermissionCollection".to_string())?,
            permissions: intermediate_rep.permissions.into_iter().next().ok_or_else(|| "permissions missing in PermissionCollection".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PermissionCollection> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PermissionCollection>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PermissionCollection>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PermissionCollection - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PermissionCollection> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PermissionCollection as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PermissionCollection - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PermissionCollectionAccount {
    #[serde(rename = "accountId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub account_id: Option<String>,

}

impl PermissionCollectionAccount {
    #[allow(clippy::new_without_default)]
    pub fn new() -> PermissionCollectionAccount {
        PermissionCollectionAccount {
            account_id: None,
        }
    }
}

/// Converts the PermissionCollectionAccount value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PermissionCollectionAccount {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.account_id.as_ref().map(|account_id| {
                vec![
                    "accountId".to_string(),
                    account_id.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PermissionCollectionAccount value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PermissionCollectionAccount {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub account_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PermissionCollectionAccount".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "accountId" => intermediate_rep.account_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PermissionCollectionAccount".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PermissionCollectionAccount {
            account_id: intermediate_rep.account_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PermissionCollectionAccount> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PermissionCollectionAccount>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PermissionCollectionAccount>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PermissionCollectionAccount - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PermissionCollectionAccount> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PermissionCollectionAccount as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PermissionCollectionAccount - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// The collective action and associate grants on a permission
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PermissionObject {
    /// The action the permission grants, can be scoped using `:` and parent actions imply sub-resource permissions, action:* or action implies action:sub-action. This property is case-insensitive, it will always be cast to lowercase before comparing actions to user permissions.
    #[serde(rename = "action")]
    pub action: String,

    /// Does this permission grant the user the ability to execute the action?
    #[serde(rename = "allow")]
    pub allow: bool,

    /// Allows the user to give the permission to others without being able to execute the action.
    #[serde(rename = "grant")]
    pub grant: bool,

    /// Allows delegating or granting the permission to others without being able to execute the action.
    #[serde(rename = "delegate")]
    pub delegate: bool,

}

impl PermissionObject {
    #[allow(clippy::new_without_default)]
    pub fn new(action: String, allow: bool, grant: bool, delegate: bool, ) -> PermissionObject {
        PermissionObject {
            action,
            allow,
            grant,
            delegate,
        }
    }
}

/// Converts the PermissionObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PermissionObject {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("action".to_string()),
            Some(self.action.to_string()),


            Some("allow".to_string()),
            Some(self.allow.to_string()),


            Some("grant".to_string()),
            Some(self.grant.to_string()),


            Some("delegate".to_string()),
            Some(self.delegate.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PermissionObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PermissionObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub action: Vec<String>,
            pub allow: Vec<bool>,
            pub grant: Vec<bool>,
            pub delegate: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PermissionObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "action" => intermediate_rep.action.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "allow" => intermediate_rep.allow.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "grant" => intermediate_rep.grant.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "delegate" => intermediate_rep.delegate.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PermissionObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PermissionObject {
            action: intermediate_rep.action.into_iter().next().ok_or_else(|| "action missing in PermissionObject".to_string())?,
            allow: intermediate_rep.allow.into_iter().next().ok_or_else(|| "allow missing in PermissionObject".to_string())?,
            grant: intermediate_rep.grant.into_iter().next().ok_or_else(|| "grant missing in PermissionObject".to_string())?,
            delegate: intermediate_rep.delegate.into_iter().next().ok_or_else(|| "delegate missing in PermissionObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PermissionObject> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PermissionObject>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PermissionObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PermissionObject - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PermissionObject> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PermissionObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PermissionObject - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PermissionedResource {
    #[serde(rename = "permissions")]
    pub permissions: Vec<models::ResourcePermission>,

}

impl PermissionedResource {
    #[allow(clippy::new_without_default)]
    pub fn new(permissions: Vec<models::ResourcePermission>, ) -> PermissionedResource {
        PermissionedResource {
            permissions,
        }
    }
}

/// Converts the PermissionedResource value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PermissionedResource {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping permissions in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PermissionedResource value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PermissionedResource {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub permissions: Vec<Vec<models::ResourcePermission>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PermissionedResource".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "permissions" => return std::result::Result::Err("Parsing a container in this style is not supported in PermissionedResource".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PermissionedResource".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PermissionedResource {
            permissions: intermediate_rep.permissions.into_iter().next().ok_or_else(|| "permissions missing in PermissionedResource".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PermissionedResource> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PermissionedResource>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PermissionedResource>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PermissionedResource - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PermissionedResource> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PermissionedResource as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PermissionedResource - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// A collection of resource permissions that have been defined.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PermissionedResourceCollection {
    #[serde(rename = "resources")]
    pub resources: Vec<models::PermissionedResource>,

    #[serde(rename = "pagination")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pagination: Option<models::Pagination>,

    #[serde(rename = "links")]
    pub links: models::CollectionLinks,

}

impl PermissionedResourceCollection {
    #[allow(clippy::new_without_default)]
    pub fn new(resources: Vec<models::PermissionedResource>, links: models::CollectionLinks, ) -> PermissionedResourceCollection {
        PermissionedResourceCollection {
            resources,
            pagination: None,
            links,
        }
    }
}

/// Converts the PermissionedResourceCollection value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PermissionedResourceCollection {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping resources in query parameter serialization

            // Skipping pagination in query parameter serialization

            // Skipping links in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PermissionedResourceCollection value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PermissionedResourceCollection {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub resources: Vec<Vec<models::PermissionedResource>>,
            pub pagination: Vec<models::Pagination>,
            pub links: Vec<models::CollectionLinks>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PermissionedResourceCollection".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "resources" => return std::result::Result::Err("Parsing a container in this style is not supported in PermissionedResourceCollection".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "pagination" => intermediate_rep.pagination.push(<models::Pagination as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "links" => intermediate_rep.links.push(<models::CollectionLinks as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PermissionedResourceCollection".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PermissionedResourceCollection {
            resources: intermediate_rep.resources.into_iter().next().ok_or_else(|| "resources missing in PermissionedResourceCollection".to_string())?,
            pagination: intermediate_rep.pagination.into_iter().next(),
            links: intermediate_rep.links.into_iter().next().ok_or_else(|| "links missing in PermissionedResourceCollection".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PermissionedResourceCollection> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PermissionedResourceCollection>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PermissionedResourceCollection>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PermissionedResourceCollection - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PermissionedResourceCollection> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PermissionedResourceCollection as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PermissionedResourceCollection - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Resource {
    /// A resource path which can be top level, fully qualified, or end with a *. Parent resources imply permissions to sub-resources.
    #[serde(rename = "resourceUri")]
    pub resource_uri: String,

}

impl Resource {
    #[allow(clippy::new_without_default)]
    pub fn new(resource_uri: String, ) -> Resource {
        Resource {
            resource_uri,
        }
    }
}

/// Converts the Resource value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Resource {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("resourceUri".to_string()),
            Some(self.resource_uri.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Resource value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Resource {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub resource_uri: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Resource".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "resourceUri" => intermediate_rep.resource_uri.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Resource".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Resource {
            resource_uri: intermediate_rep.resource_uri.into_iter().next().ok_or_else(|| "resourceUri missing in Resource".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Resource> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Resource>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Resource>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Resource - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Resource> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Resource as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Resource - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ResourcePermission {
    // Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "action")]
    pub action: String,

    #[serde(rename = "allow")]
    pub allow: bool,

}

impl ResourcePermission {
    #[allow(clippy::new_without_default)]
    pub fn new(action: String, allow: bool, ) -> ResourcePermission {
        ResourcePermission {
            action,
            allow,
        }
    }
}

/// Converts the ResourcePermission value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ResourcePermission {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("action".to_string()),
            Some(self.action.to_string()),


            Some("allow".to_string()),
            Some(self.allow.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ResourcePermission value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ResourcePermission {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub action: Vec<String>,
            pub allow: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ResourcePermission".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "action" => intermediate_rep.action.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "allow" => intermediate_rep.allow.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ResourcePermission".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ResourcePermission {
            action: intermediate_rep.action.into_iter().next().ok_or_else(|| "action missing in ResourcePermission".to_string())?,
            allow: intermediate_rep.allow.into_iter().next().ok_or_else(|| "allow missing in ResourcePermission".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ResourcePermission> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ResourcePermission>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ResourcePermission>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ResourcePermission - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ResourcePermission> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ResourcePermission as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ResourcePermission - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// A collection of users with explicit permission to a resource.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ResourceUsersCollection {
    /// A list of users
    #[serde(rename = "users")]
    pub users: Vec<models::UserRoleCollection>,

    #[serde(rename = "pagination")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pagination: Option<models::Pagination>,

    #[serde(rename = "links")]
    pub links: models::CollectionLinks,

}

impl ResourceUsersCollection {
    #[allow(clippy::new_without_default)]
    pub fn new(users: Vec<models::UserRoleCollection>, links: models::CollectionLinks, ) -> ResourceUsersCollection {
        ResourceUsersCollection {
            users,
            pagination: None,
            links,
        }
    }
}

/// Converts the ResourceUsersCollection value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ResourceUsersCollection {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping users in query parameter serialization

            // Skipping pagination in query parameter serialization

            // Skipping links in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ResourceUsersCollection value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ResourceUsersCollection {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub users: Vec<Vec<models::UserRoleCollection>>,
            pub pagination: Vec<models::Pagination>,
            pub links: Vec<models::CollectionLinks>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ResourceUsersCollection".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "users" => return std::result::Result::Err("Parsing a container in this style is not supported in ResourceUsersCollection".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "pagination" => intermediate_rep.pagination.push(<models::Pagination as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "links" => intermediate_rep.links.push(<models::CollectionLinks as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ResourceUsersCollection".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ResourceUsersCollection {
            users: intermediate_rep.users.into_iter().next().ok_or_else(|| "users missing in ResourceUsersCollection".to_string())?,
            pagination: intermediate_rep.pagination.into_iter().next(),
            links: intermediate_rep.links.into_iter().next().ok_or_else(|| "links missing in ResourceUsersCollection".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ResourceUsersCollection> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ResourceUsersCollection>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ResourceUsersCollection>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ResourceUsersCollection - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ResourceUsersCollection> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ResourceUsersCollection as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ResourceUsersCollection - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// The role which contains a list of permissions.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Role {
    /// Unique identifier for the role, can be specified on creation, and used by records to map to permissions.
    #[serde(rename = "roleId")]
    pub role_id: String,

    /// A helpful name for this role
    #[serde(rename = "name")]
    pub name: String,

    /// A description for when to the user as well as additional information.
    #[serde(rename = "description")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<swagger::Nullable<String>>,

    /// A list of the permissions
    #[serde(rename = "permissions")]
    pub permissions: Vec<models::PermissionObject>,

}

impl Role {
    #[allow(clippy::new_without_default)]
    pub fn new(role_id: String, name: String, permissions: Vec<models::PermissionObject>, ) -> Role {
        Role {
            role_id,
            name,
            description: None,
            permissions,
        }
    }
}

/// Converts the Role value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Role {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("roleId".to_string()),
            Some(self.role_id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),


            self.description.as_ref().map(|description| {
                vec![
                    "description".to_string(),
                    description.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping permissions in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Role value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Role {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub role_id: Vec<String>,
            pub name: Vec<String>,
            pub description: Vec<String>,
            pub permissions: Vec<Vec<models::PermissionObject>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Role".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "roleId" => intermediate_rep.role_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "description" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Role".to_string()),
                    "permissions" => return std::result::Result::Err("Parsing a container in this style is not supported in Role".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing Role".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Role {
            role_id: intermediate_rep.role_id.into_iter().next().ok_or_else(|| "roleId missing in Role".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in Role".to_string())?,
            description: std::result::Result::Err("Nullable types not supported in Role".to_string())?,
            permissions: intermediate_rep.permissions.into_iter().next().ok_or_else(|| "permissions missing in Role".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Role> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Role>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Role>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Role - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Role> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Role as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Role - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// A collection of roles
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RoleCollection {
    /// A list of roles
    #[serde(rename = "roles")]
    pub roles: Vec<models::Role>,

    #[serde(rename = "pagination")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pagination: Option<models::Pagination>,

    #[serde(rename = "links")]
    pub links: models::CollectionLinks,

}

impl RoleCollection {
    #[allow(clippy::new_without_default)]
    pub fn new(roles: Vec<models::Role>, links: models::CollectionLinks, ) -> RoleCollection {
        RoleCollection {
            roles,
            pagination: None,
            links,
        }
    }
}

/// Converts the RoleCollection value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for RoleCollection {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping roles in query parameter serialization

            // Skipping pagination in query parameter serialization

            // Skipping links in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RoleCollection value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RoleCollection {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub roles: Vec<Vec<models::Role>>,
            pub pagination: Vec<models::Pagination>,
            pub links: Vec<models::CollectionLinks>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RoleCollection".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "roles" => return std::result::Result::Err("Parsing a container in this style is not supported in RoleCollection".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "pagination" => intermediate_rep.pagination.push(<models::Pagination as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "links" => intermediate_rep.links.push(<models::CollectionLinks as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RoleCollection".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RoleCollection {
            roles: intermediate_rep.roles.into_iter().next().ok_or_else(|| "roles missing in RoleCollection".to_string())?,
            pagination: intermediate_rep.pagination.into_iter().next(),
            links: intermediate_rep.links.into_iter().next().ok_or_else(|| "links missing in RoleCollection".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RoleCollection> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<RoleCollection>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RoleCollection>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RoleCollection - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<RoleCollection> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RoleCollection as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RoleCollection - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Statement {
    #[serde(rename = "roles")]
    pub roles: Vec<String>,

    #[serde(rename = "resources")]
    pub resources: Vec<models::Resource>,

    /// The list of users this statement applies to. Users and groups can be set at either the statement level or the record level, but not both.
    #[serde(rename = "users")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub users: Option<Vec<models::User>>,

    /// The list of groups this statement applies to. Users in these groups will be receive access to the resources listed. Users and groups can be set at either the statement level or the record level, but not both.
    #[serde(rename = "groups")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub groups: Option<Vec<models::LinkedGroup>>,

}

impl Statement {
    #[allow(clippy::new_without_default)]
    pub fn new(roles: Vec<String>, resources: Vec<models::Resource>, ) -> Statement {
        Statement {
            roles,
            resources,
            users: None,
            groups: None,
        }
    }
}

/// Converts the Statement value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Statement {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("roles".to_string()),
            Some(self.roles.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

            // Skipping resources in query parameter serialization

            // Skipping users in query parameter serialization

            // Skipping groups in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Statement value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Statement {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub roles: Vec<Vec<String>>,
            pub resources: Vec<Vec<models::Resource>>,
            pub users: Vec<Vec<models::User>>,
            pub groups: Vec<Vec<models::LinkedGroup>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Statement".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "roles" => return std::result::Result::Err("Parsing a container in this style is not supported in Statement".to_string()),
                    "resources" => return std::result::Result::Err("Parsing a container in this style is not supported in Statement".to_string()),
                    "users" => return std::result::Result::Err("Parsing a container in this style is not supported in Statement".to_string()),
                    "groups" => return std::result::Result::Err("Parsing a container in this style is not supported in Statement".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing Statement".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Statement {
            roles: intermediate_rep.roles.into_iter().next().ok_or_else(|| "roles missing in Statement".to_string())?,
            resources: intermediate_rep.resources.into_iter().next().ok_or_else(|| "resources missing in Statement".to_string())?,
            users: intermediate_rep.users.into_iter().next(),
            groups: intermediate_rep.groups.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Statement> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Statement>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Statement>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Statement - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Statement> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Statement as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Statement - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Tenant {
    #[serde(rename = "tenantId")]
    pub tenant_id: String,

    #[serde(rename = "tenantLookupIdentifier")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tenant_lookup_identifier: Option<swagger::Nullable<String>>,

    #[serde(rename = "data")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub data: Option<models::TenantData>,

    #[serde(rename = "connection")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub connection: Option<swagger::Nullable<models::TenantConnection>>,

    #[serde(rename = "createdTime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_time: Option<chrono::DateTime::<chrono::Utc>>,

}

impl Tenant {
    #[allow(clippy::new_without_default)]
    pub fn new(tenant_id: String, ) -> Tenant {
        Tenant {
            tenant_id,
            tenant_lookup_identifier: None,
            data: None,
            connection: None,
            created_time: None,
        }
    }
}

/// Converts the Tenant value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Tenant {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("tenantId".to_string()),
            Some(self.tenant_id.to_string()),


            self.tenant_lookup_identifier.as_ref().map(|tenant_lookup_identifier| {
                vec![
                    "tenantLookupIdentifier".to_string(),
                    tenant_lookup_identifier.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping data in query parameter serialization

            // Skipping connection in query parameter serialization

            // Skipping createdTime in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Tenant value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Tenant {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub tenant_id: Vec<String>,
            pub tenant_lookup_identifier: Vec<String>,
            pub data: Vec<models::TenantData>,
            pub connection: Vec<models::TenantConnection>,
            pub created_time: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Tenant".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "tenantId" => intermediate_rep.tenant_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "tenantLookupIdentifier" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Tenant".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::TenantData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "connection" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Tenant".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "createdTime" => intermediate_rep.created_time.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Tenant".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Tenant {
            tenant_id: intermediate_rep.tenant_id.into_iter().next().ok_or_else(|| "tenantId missing in Tenant".to_string())?,
            tenant_lookup_identifier: std::result::Result::Err("Nullable types not supported in Tenant".to_string())?,
            data: intermediate_rep.data.into_iter().next(),
            connection: std::result::Result::Err("Nullable types not supported in Tenant".to_string())?,
            created_time: intermediate_rep.created_time.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Tenant> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Tenant>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Tenant>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Tenant - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Tenant> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Tenant as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Tenant - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// A collection of tenants.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TenantCollection {
    #[serde(rename = "tenants")]
    pub tenants: Vec<models::Tenant>,

    #[serde(rename = "pagination")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pagination: Option<models::Pagination>,

}

impl TenantCollection {
    #[allow(clippy::new_without_default)]
    pub fn new(tenants: Vec<models::Tenant>, ) -> TenantCollection {
        TenantCollection {
            tenants,
            pagination: None,
        }
    }
}

/// Converts the TenantCollection value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TenantCollection {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping tenants in query parameter serialization

            // Skipping pagination in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TenantCollection value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TenantCollection {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub tenants: Vec<Vec<models::Tenant>>,
            pub pagination: Vec<models::Pagination>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TenantCollection".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "tenants" => return std::result::Result::Err("Parsing a container in this style is not supported in TenantCollection".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "pagination" => intermediate_rep.pagination.push(<models::Pagination as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing TenantCollection".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TenantCollection {
            tenants: intermediate_rep.tenants.into_iter().next().ok_or_else(|| "tenants missing in TenantCollection".to_string())?,
            pagination: intermediate_rep.pagination.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TenantCollection> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TenantCollection>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TenantCollection>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for TenantCollection - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<TenantCollection> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TenantCollection as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into TenantCollection - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TenantConnection {
    #[serde(rename = "connectionId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub connection_id: Option<String>,

}

impl TenantConnection {
    #[allow(clippy::new_without_default)]
    pub fn new() -> TenantConnection {
        TenantConnection {
            connection_id: None,
        }
    }
}

/// Converts the TenantConnection value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TenantConnection {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.connection_id.as_ref().map(|connection_id| {
                vec![
                    "connectionId".to_string(),
                    connection_id.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TenantConnection value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TenantConnection {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub connection_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TenantConnection".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "connectionId" => intermediate_rep.connection_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing TenantConnection".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TenantConnection {
            connection_id: intermediate_rep.connection_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TenantConnection> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TenantConnection>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TenantConnection>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for TenantConnection - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<TenantConnection> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TenantConnection as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into TenantConnection - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TenantData {
    #[serde(rename = "name")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<swagger::Nullable<String>>,

}

impl TenantData {
    #[allow(clippy::new_without_default)]
    pub fn new() -> TenantData {
        TenantData {
            name: None,
        }
    }
}

/// Converts the TenantData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TenantData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.name.as_ref().map(|name| {
                vec![
                    "name".to_string(),
                    name.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TenantData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TenantData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TenantData".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "name" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in TenantData".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing TenantData".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TenantData {
            name: std::result::Result::Err("Nullable types not supported in TenantData".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TenantData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TenantData>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TenantData>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for TenantData - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<TenantData> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TenantData as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into TenantData - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TokenRequest {
    /// A list of statements which match roles to resources. The token will have all statements apply to it.
    #[serde(rename = "statements")]
    pub statements: Vec<models::Statement>,

    /// The ISO8601 datetime when the token will expire. Default is 24 hours from now.
    #[serde(rename = "expires")]
    pub expires: chrono::DateTime::<chrono::Utc>,

}

impl TokenRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(statements: Vec<models::Statement>, expires: chrono::DateTime::<chrono::Utc>, ) -> TokenRequest {
        TokenRequest {
            statements,
            expires,
        }
    }
}

/// Converts the TokenRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TokenRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping statements in query parameter serialization

            // Skipping expires in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TokenRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TokenRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub statements: Vec<Vec<models::Statement>>,
            pub expires: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TokenRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "statements" => return std::result::Result::Err("Parsing a container in this style is not supported in TokenRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "expires" => intermediate_rep.expires.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing TokenRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TokenRequest {
            statements: intermediate_rep.statements.into_iter().next().ok_or_else(|| "statements missing in TokenRequest".to_string())?,
            expires: intermediate_rep.expires.into_iter().next().ok_or_else(|| "expires missing in TokenRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TokenRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TokenRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TokenRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for TokenRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<TokenRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TokenRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into TokenRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// A user object that identifies a user.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct User {
    #[serde(rename = "userId")]
    pub user_id: String,

}

impl User {
    #[allow(clippy::new_without_default)]
    pub fn new(user_id: String, ) -> User {
        User {
            user_id,
        }
    }
}

/// Converts the User value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for User {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("userId".to_string()),
            Some(self.user_id.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a User value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for User {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub user_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing User".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "userId" => intermediate_rep.user_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing User".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(User {
            user_id: intermediate_rep.user_id.into_iter().next().ok_or_else(|| "userId missing in User".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<User> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<User>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<User>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for User - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<User> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <User as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into User - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// The user credentials for this connection which can be used to access the connection provider APIs.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UserConnectionCredentials {
    /// The access token.
    #[serde(rename = "accessToken")]
    pub access_token: String,

}

impl UserConnectionCredentials {
    #[allow(clippy::new_without_default)]
    pub fn new(access_token: String, ) -> UserConnectionCredentials {
        UserConnectionCredentials {
            access_token,
        }
    }
}

/// Converts the UserConnectionCredentials value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UserConnectionCredentials {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("accessToken".to_string()),
            Some(self.access_token.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UserConnectionCredentials value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UserConnectionCredentials {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub access_token: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UserConnectionCredentials".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "accessToken" => intermediate_rep.access_token.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UserConnectionCredentials".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UserConnectionCredentials {
            access_token: intermediate_rep.access_token.into_iter().next().ok_or_else(|| "accessToken missing in UserConnectionCredentials".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UserConnectionCredentials> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UserConnectionCredentials>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UserConnectionCredentials>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UserConnectionCredentials - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UserConnectionCredentials> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UserConnectionCredentials as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UserConnectionCredentials - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// The user composite user identity stored in Authress sourced by the customer SSO/SAML/OAuth IdP.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UserIdentity {
    /// The user identifier.
    #[serde(rename = "userId")]
    pub user_id: String,

    /// The user's formatted display name.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    /// A url that resolves to a picture that can be rendered.
    #[serde(rename = "picture")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub picture: Option<String>,

    /// The user's verified email address sourced from their SSO IdP.
    #[serde(rename = "email")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,

}

impl UserIdentity {
    #[allow(clippy::new_without_default)]
    pub fn new(user_id: String, ) -> UserIdentity {
        UserIdentity {
            user_id,
            name: None,
            picture: None,
            email: None,
        }
    }
}

/// Converts the UserIdentity value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UserIdentity {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("userId".to_string()),
            Some(self.user_id.to_string()),


            self.name.as_ref().map(|name| {
                vec![
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.picture.as_ref().map(|picture| {
                vec![
                    "picture".to_string(),
                    picture.to_string(),
                ].join(",")
            }),


            self.email.as_ref().map(|email| {
                vec![
                    "email".to_string(),
                    email.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UserIdentity value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UserIdentity {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub user_id: Vec<String>,
            pub name: Vec<String>,
            pub picture: Vec<String>,
            pub email: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UserIdentity".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "userId" => intermediate_rep.user_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "picture" => intermediate_rep.picture.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "email" => intermediate_rep.email.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UserIdentity".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UserIdentity {
            user_id: intermediate_rep.user_id.into_iter().next().ok_or_else(|| "userId missing in UserIdentity".to_string())?,
            name: intermediate_rep.name.into_iter().next(),
            picture: intermediate_rep.picture.into_iter().next(),
            email: intermediate_rep.email.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UserIdentity> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UserIdentity>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UserIdentity>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UserIdentity - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UserIdentity> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UserIdentity as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UserIdentity - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// A collection of user identities
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UserIdentityCollection {
    /// A list of users
    #[serde(rename = "users")]
    pub users: Vec<models::UserIdentity>,

    #[serde(rename = "pagination")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pagination: Option<models::Pagination>,

    #[serde(rename = "links")]
    pub links: models::CollectionLinks,

}

impl UserIdentityCollection {
    #[allow(clippy::new_without_default)]
    pub fn new(users: Vec<models::UserIdentity>, links: models::CollectionLinks, ) -> UserIdentityCollection {
        UserIdentityCollection {
            users,
            pagination: None,
            links,
        }
    }
}

/// Converts the UserIdentityCollection value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UserIdentityCollection {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping users in query parameter serialization

            // Skipping pagination in query parameter serialization

            // Skipping links in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UserIdentityCollection value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UserIdentityCollection {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub users: Vec<Vec<models::UserIdentity>>,
            pub pagination: Vec<models::Pagination>,
            pub links: Vec<models::CollectionLinks>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UserIdentityCollection".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "users" => return std::result::Result::Err("Parsing a container in this style is not supported in UserIdentityCollection".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "pagination" => intermediate_rep.pagination.push(<models::Pagination as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "links" => intermediate_rep.links.push(<models::CollectionLinks as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UserIdentityCollection".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UserIdentityCollection {
            users: intermediate_rep.users.into_iter().next().ok_or_else(|| "users missing in UserIdentityCollection".to_string())?,
            pagination: intermediate_rep.pagination.into_iter().next(),
            links: intermediate_rep.links.into_iter().next().ok_or_else(|| "links missing in UserIdentityCollection".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UserIdentityCollection> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UserIdentityCollection>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UserIdentityCollection>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UserIdentityCollection - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UserIdentityCollection> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UserIdentityCollection as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UserIdentityCollection - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// A collect of permissions that the user has to a resource.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UserResources {
    #[serde(rename = "account")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub account: Option<models::PermissionCollectionAccount>,

    #[serde(rename = "userId")]
    pub user_id: String,

    /// A list of the resources the user has some permission to.
    #[serde(rename = "resources")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub resources: Option<Vec<models::Resource>>,

    #[serde(rename = "pagination")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pagination: Option<models::Pagination>,

    #[serde(rename = "links")]
    pub links: models::CollectionLinks,

}

impl UserResources {
    #[allow(clippy::new_without_default)]
    pub fn new(user_id: String, links: models::CollectionLinks, ) -> UserResources {
        UserResources {
            account: None,
            user_id,
            resources: None,
            pagination: None,
            links,
        }
    }
}

/// Converts the UserResources value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UserResources {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping account in query parameter serialization

            // Skipping userId in query parameter serialization

            // Skipping resources in query parameter serialization

            // Skipping pagination in query parameter serialization

            // Skipping links in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UserResources value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UserResources {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub account: Vec<models::PermissionCollectionAccount>,
            pub user_id: Vec<String>,
            pub resources: Vec<Vec<models::Resource>>,
            pub pagination: Vec<models::Pagination>,
            pub links: Vec<models::CollectionLinks>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UserResources".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "account" => intermediate_rep.account.push(<models::PermissionCollectionAccount as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "userId" => intermediate_rep.user_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "resources" => return std::result::Result::Err("Parsing a container in this style is not supported in UserResources".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "pagination" => intermediate_rep.pagination.push(<models::Pagination as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "links" => intermediate_rep.links.push(<models::CollectionLinks as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UserResources".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UserResources {
            account: intermediate_rep.account.into_iter().next(),
            user_id: intermediate_rep.user_id.into_iter().next().ok_or_else(|| "userId missing in UserResources".to_string())?,
            resources: intermediate_rep.resources.into_iter().next(),
            pagination: intermediate_rep.pagination.into_iter().next(),
            links: intermediate_rep.links.into_iter().next().ok_or_else(|| "links missing in UserResources".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UserResources> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UserResources>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UserResources>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UserResources - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UserResources> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UserResources as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UserResources - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// A role with associated role data.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UserRole {
    #[serde(rename = "roleId")]
    pub role_id: String,

}

impl UserRole {
    #[allow(clippy::new_without_default)]
    pub fn new(role_id: String, ) -> UserRole {
        UserRole {
            role_id,
        }
    }
}

/// Converts the UserRole value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UserRole {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping roleId in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UserRole value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UserRole {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub role_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UserRole".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "roleId" => intermediate_rep.role_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UserRole".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UserRole {
            role_id: intermediate_rep.role_id.into_iter().next().ok_or_else(|| "roleId missing in UserRole".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UserRole> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UserRole>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UserRole>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UserRole - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UserRole> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UserRole as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UserRole - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// A collect of roles that the user has to a resource.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UserRoleCollection {
    #[serde(rename = "userId")]
    pub user_id: String,

    /// A list of the roles
    #[serde(rename = "roles")]
    pub roles: Vec<models::UserRole>,

}

impl UserRoleCollection {
    #[allow(clippy::new_without_default)]
    pub fn new(user_id: String, roles: Vec<models::UserRole>, ) -> UserRoleCollection {
        UserRoleCollection {
            user_id,
            roles,
        }
    }
}

/// Converts the UserRoleCollection value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UserRoleCollection {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping userId in query parameter serialization

            // Skipping roles in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UserRoleCollection value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UserRoleCollection {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub user_id: Vec<String>,
            pub roles: Vec<Vec<models::UserRole>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UserRoleCollection".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "userId" => intermediate_rep.user_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "roles" => return std::result::Result::Err("Parsing a container in this style is not supported in UserRoleCollection".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing UserRoleCollection".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UserRoleCollection {
            user_id: intermediate_rep.user_id.into_iter().next().ok_or_else(|| "userId missing in UserRoleCollection".to_string())?,
            roles: intermediate_rep.roles.into_iter().next().ok_or_else(|| "roles missing in UserRoleCollection".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UserRoleCollection> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UserRoleCollection>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UserRoleCollection>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UserRoleCollection - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UserRoleCollection> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UserRoleCollection as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UserRoleCollection - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// A JWT token with represents the user.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UserToken {
    #[serde(rename = "account")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub account: Option<models::PermissionCollectionAccount>,

    #[serde(rename = "userId")]
    pub user_id: String,

    /// The unique identifier for the token
    #[serde(rename = "tokenId")]
    pub token_id: String,

    /// The access token
    #[serde(rename = "token")]
    pub token: String,

    #[serde(rename = "links")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub links: Option<models::AccountLinks>,

}

impl UserToken {
    #[allow(clippy::new_without_default)]
    pub fn new(user_id: String, token_id: String, token: String, ) -> UserToken {
        UserToken {
            account: None,
            user_id,
            token_id,
            token,
            links: None,
        }
    }
}

/// Converts the UserToken value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UserToken {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping account in query parameter serialization

            // Skipping userId in query parameter serialization


            Some("tokenId".to_string()),
            Some(self.token_id.to_string()),


            Some("token".to_string()),
            Some(self.token.to_string()),

            // Skipping links in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UserToken value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UserToken {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub account: Vec<models::PermissionCollectionAccount>,
            pub user_id: Vec<String>,
            pub token_id: Vec<String>,
            pub token: Vec<String>,
            pub links: Vec<models::AccountLinks>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UserToken".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "account" => intermediate_rep.account.push(<models::PermissionCollectionAccount as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "userId" => intermediate_rep.user_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "tokenId" => intermediate_rep.token_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "token" => intermediate_rep.token.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "links" => intermediate_rep.links.push(<models::AccountLinks as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UserToken".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UserToken {
            account: intermediate_rep.account.into_iter().next(),
            user_id: intermediate_rep.user_id.into_iter().next().ok_or_else(|| "userId missing in UserToken".to_string())?,
            token_id: intermediate_rep.token_id.into_iter().next().ok_or_else(|| "tokenId missing in UserToken".to_string())?,
            token: intermediate_rep.token.into_iter().next().ok_or_else(|| "token missing in UserToken".to_string())?,
            links: intermediate_rep.links.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UserToken> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UserToken>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UserToken>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UserToken - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UserToken> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UserToken as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UserToken - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

